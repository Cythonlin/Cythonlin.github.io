<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cythonlin.github.io</id>
    <title>Cython_lin</title>
    <updated>2020-09-29T03:47:52.324Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cythonlin.github.io"/>
    <link rel="self" href="https://cythonlin.github.io/atom.xml"/>
    <logo>https://cythonlin.github.io/images/avatar.png</logo>
    <icon>https://cythonlin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Cython_lin</rights>
    <entry>
        <title type="html"><![CDATA[PY => PY38]]></title>
        <id>https://cythonlin.github.io/post/py-greater-py38/</id>
        <link href="https://cythonlin.github.io/post/py-greater-py38/">
        </link>
        <updated>2020-09-29T03:47:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明">说明</h1>
<p>本篇文章介绍Python3.8的一些较为好用的新特性</p>
<h1 id="赋值表达式">赋值表达式</h1>
<h3 id="语法格式">语法格式：</h3>
<p>2种格式的区别就是，一个带括号，一个不用带括号<br>
(a:=1)<br>
a:=1<br>
其实这两种格式结果是一样的，只是有些情况括号可以省略不写而已。</p>
<h3 id="括号可省的情况">括号可省的情况</h3>
<h3 id="一-序列类型中-括号可省">#一、序列类型中 括号可省</h3>
<pre><code>[a:=1, 2]
</code></pre>
<h4 id="二-作为函数调用的参数-括号可省">二、作为函数调用的参数 括号可省</h4>
<pre><code># 注意我说的是函数调用，函数定义的时候压根就不能用 := 表达式，更别提可不可省了
print(g:=1)
</code></pre>
<h4 id="三-以后碰见再说了应该也没啥了">三、以后碰见再说了，应该也没啥了</h4>
<h3 id="括号不可省的情况">括号不可省的情况</h3>
<h4 id="一-在while-if-for语句的条件中虽可省但不要省">一、在while(), if(), for()语句的条件中（虽可省但不要省）</h4>
<pre><code>while ((b:=1) == 2): # if， for 同理
	print(2)
print(b)
# &gt;&gt; 1    
</code></pre>
<p>强调1  := 此运算符优先级比 == 还低，虽然可省，所以这里区分语义括号要加上<br>
强调2  := 就算while 或者 if 条件不成立， b依然赋值成功</p>
<h4 id="二-在-f-string-中括号不可省-某些情况可省虽可省但不要省">二、在 f-string 中，括号不可省 （某些情况可省，虽可省但不要省）</h4>
<pre><code>f'{(p:=1)}'
print(p)
</code></pre>
<p>假如新变量q是未定义的，不加括号就会出现如下情况（所以这样用就没意义了， f-string括号必须加）<br>
f'{q:=1}'<br>
print(p)<br>
# NameError: name 's' is not defined</p>
<h4 id="三-以后碰见再说了也没啥了">三、以后碰见再说了，也没啥了</h4>
<h1 id="f-string新增功能">f-string新增功能</h1>
<p>3.8之前这么用:<br>
f'{loss}, {acc}'<br>
#&gt;&gt; '0.0141, 0.98912'<br>
3.8之后这么用:<br>
f'{loss=}, {acc=}'<br>
#&gt;&gt; 'loss=0.0141, acc=0.98912'</p>
<p>还有个功能(自己看结果对比的效果把):<br>
name = 'zhang'<br>
f'{name}'      # 'zhang'<br>
f'{name=}'     # &quot;name='zhang'&quot;      # 新增功能1<br>
f'{name=!s}'    # 'name=zhang'       # 新增功能2</p>
<h1 id="欧氏距离">欧氏距离</h1>
<pre><code>import math
math.dist([1,2,3,4],[5,6,7,8])
</code></pre>
<h1 id="f-string回顾36就已经出了一直在用">f-string回顾(3.6就已经出了，一直在用)</h1>
<h3 id="方式0-提前说明方式6-和-方式7上档次-好用">方式0: 提前说明(方式6 和 方式7上档次, 好用)</h3>
<h3 id="方式1变量替换">方式1：变量替换</h3>
<pre><code>name = 'zhang'
print( f'{name}' )
#&gt;&gt; zhang
</code></pre>
<h3 id="方式2内嵌表达式计算">方式2：内嵌表达式计算</h3>
<pre><code>name = 'zhang'
print( f'{name.upper()}' )
#&gt;&gt; ZHANG
</code></pre>
<h3 id="方式3一行写不下可以多行-f-注意不需要逗号分隔并且要用小括号扩起来">方式3：一行写不下，可以多行 f''  (注意，不需要逗号分隔)，并且要用小括号扩起来</h3>
<pre><code>name = 'zhang'
age = 18
gender = 'man'
a = (
	f'name={name}   '
	f'age={age}   '
	f'gender={gender}   '
)
print(a)
#&gt;&gt; name=zhang   age=18   gender=man   
</code></pre>
<h3 id="方式4转义">方式4：转义 {}</h3>
<pre><code># 注意一下， 
# f'{ ' 这种会报错的
# 因为 { 在 f''语句里面已经不是字符串了， 而是语法符号
# 如果我们想要  {} 这种字符串， 如下解决办法
	# 用 { 来转义 {
	# 用 } 来转义 }
eg:
	f'{{'
	输出为&gt;&gt; '{'
    
	f'}}'
	输出为 &gt;&gt; '}'
</code></pre>
<h3 id="方式5符号格式">方式5：符号格式</h3>
<pre><code>正号：
	import random
	b = random.randint(0,5)
	f'{b:+}'
	#&gt;&gt; +0
</code></pre>
<h3 id="方式6日期符号格式特别好用适用于-timedatedatetime对象">方式6：日期符号格式（特别好用，适用于 time,date,datetime对象）</h3>
<pre><code>from datetime import datetime
e = datetime.now()

# 年月日时分秒
f'{e:%Y}' # '2020'  表示2020年 (注意是大写的Y)
f'{e:%m}' # '09'    表示9月份 （自动补0）(注意是小写m)
f'{e:%d}' # '02'    表示2号
f'{e:%H}' # '21'    表示21点了 (24小时制)
f'{e:%M}' # '43'    表示43分了 (注意是大写的M)
f'{e:%S}' # '50'    表示50秒了 (注意是大写的S)

# 默认组合格式(分隔符是固定的)
f'{e:%F}' # '2020-09-02'   年-月-日,  分割符是固定的 '-'
f'{e:%T}' # '21:58:39'     时:分:秒,  分割符是固定的 ':'  (大写的X一摸一样)

# 基于上面2行自己组装一下,形成完整时间
f'{e:%F %T}' # '2020-09-02 22:02:29'   上面2种组装一下

# 星期几+ 每年的第几天 + 每年的第几周
f'{e:%j}' # '246'   表示一年中的第 246 天, 个位数前面补0,至3位
f'{e:%u}' # '3'     表示星期3  （星期日是7）
f'{e:%W}' # '35'    表示一年中的第 35周, 个位数前面补0,至2位(注意是大写的W)
</code></pre>
<h3 id="方式7-精度占位符号后面不要有空格这个较难理解">方式7: 精度占位符号(:后面不要有空格)(这个较难理解)</h3>
<p>情况一、:.n 代表只保留前n位 (并且四舍五入)(总体位数不算小数点所在的位数)<br>
f&quot;{1234.5678:.6}&quot;     # .6  表示保留6位 (不算小数点, 整数+小数=6位)<br>
#&gt;&gt; '1234.57'<br>
情况二、:m 代表只在&quot;最前面&quot;扩充&quot;至&quot;m位(注意这个&quot;至&quot;字)<br>
f&quot;{1234.5678:15}&quot;         # 扩充至15位(小数点也算位数) 默认用空白字符代替<br>
#&gt;&gt; '      1234.5678'<br>
情况三、:m前面带0， 补充空字符串 改为 &quot;补0&quot;<br>
f&quot;{1234.5678:015}&quot;    # 0代表扩充的多余位数补0 (小数点也算位数)15代表最前面扩充至15位<br>
#&gt;&gt; '0000001234.5678'<br>
综合情况、:m.n 结合(只能是 m.n 这种顺序的格式)<br>
f&quot;{1234.5678:015.6}&quot;    # 15就是上面说的m, 0就是m前面补的0, 6就是上面说的n<br>
#&gt;&gt; '000000001234.57'</p>
<pre><code># 重点解读上面这个综合语句(按照下面的顺序才能正确解析):
1. 先看.后面的 n,  n是6,  则 整体(整数+小数)(不包括小数点)保留6位 ===&gt; '1234.57'
2. 然后才看 m,  m是15,   则在最前面扩充&quot;至&quot;15位置(包括小数点的位数) ===&gt; '        1234.57'
3. 最后把第2步的空白字符补0    =====&gt;  '000000001234.57'
</code></pre>
<p>情况四、:m.nf (推荐, 上面&quot;情况一&quot; 和 &quot;综合情况的延申版&quot;, 针对.n设计的, 多了个f,好用多了!)<br>
'''加了f,  核心就是 .n规则变为  小数点后保留n位,其余没变  '''</p>
<pre><code>eg1: .nf的情况  (这种是最常用的!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)
	f&quot;{1234.5678:.6f}&quot;       # 小数点后保留6位, 其余还是那样
	#&gt;&gt; '1234.567800'        
    
eg2: m.nf的情况
	f&quot;{1234.5678:015.6f}&quot;     # 还是前面&quot;综合情况&quot;, 先看n, n是6, 所以 &quot;小数点后&quot; 保留6位(四舍五入), 
    						 # 然后从前面扩张整体位数 &quot;至&quot;15位, 空缺的补0即可
	'00001234.567800'        
</code></pre>
<p>情况五: 百分位(作为训练acc, 也算比较常用)<br>
&quot;&quot;&quot;<br>
分析核心思想:<br>
1. 先将原数扩大100倍(也就是小数点向后移2位),<br>
2. 然后关注 .n  , 保留小数点后的n位(四舍五入)<br>
3. 最后加个百分号%, 即可)<br>
&quot;&quot;&quot;<br>
f&quot;{1234.5678:.1%}&quot;<br>
#&gt;&gt; '123456.8%'</p>
<pre><code>f&quot;{1234.5678:.6%}&quot;
#&gt;&gt; '123456.780000%'

# 如果想带m,也可以,和上面集中情况,以及解析顺序一摸一样,m不太常用, 我这里就不列了</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GO => JetBrains全家桶初始化默认配置]]></title>
        <id>https://cythonlin.github.io/post/go-greater-jetbrains-quan-jia-tong-chu-shi-hua-mo-ren-pei-zhi/</id>
        <link href="https://cythonlin.github.io/post/go-greater-jetbrains-quan-jia-tong-chu-shi-hua-mo-ren-pei-zhi/">
        </link>
        <updated>2020-09-29T03:47:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="声明">声明</h1>
<p>我只用过 Pycharm 和 Goland且有效。<br>
其他像 IDEA, WS 等血缘产品应该同样有效~~~~。</p>
<h1 id="原因">原因</h1>
<p>改语法提示组合键，改崩了。</p>
<h1 id="恢复默认配置">恢复默认配置</h1>
<pre><code>File -&gt; 
    Manage IDE Settings -&gt; 
        Restore Default Settings
</code></pre>
<h1 id="插曲">插曲</h1>
<pre><code>&quot;找配置文件,并删除&quot; if &quot;你不嫌麻烦&quot; else &quot;老老实实按照上面做&quot;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sublime-Py插件]]></title>
        <id>https://cythonlin.github.io/post/sublime-py-cha-jian/</id>
        <link href="https://cythonlin.github.io/post/sublime-py-cha-jian/">
        </link>
        <updated>2020-09-29T03:45:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="sublime-py插件">Sublime-Py插件</h1>
<pre><code>localizeMenu		# 汉化插件   帮助-&gt; language中就能找到
autofilename		# 文件路径提示
SublimeCodeIntel 	# 基本格式补全
SublimeLinter		# 代码pep8格式检查
Python PEP8 Autoformat 插件	# ctrl + shift + R   自动格式化
anaconda 		# 真正的代码补全
</code></pre>
<p>去除白框：<br>
Anaconda的settings里面配置<br>
{&quot;anaconda_linting&quot;:false} 即可</p>
<h1 id="vuestylus插件之前用的">Vue+Stylus插件（之前用的）</h1>
<pre><code>Vuejs Snippets
Vue Syntax Highlight
VueFormatter
Vuetify
Stylus-Snippets
Stylus</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => RabbitMQ/Pika使用记录]]></title>
        <id>https://cythonlin.github.io/post/py-greater-rabbitmqpika-shi-yong-ji-lu/</id>
        <link href="https://cythonlin.github.io/post/py-greater-rabbitmqpika-shi-yong-ji-lu/">
        </link>
        <updated>2020-09-29T03:44:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="安装">安装</h1>
<pre><code>https://github.com/docker-library/docs/tree/master/rabbitmq
docker run -d --hostname my-rabbit -p 5672:5672 --name some-rabbit rabbitmq:3
</code></pre>
<h1 id="无交换机">无交换机</h1>
<p>基本机制：生产者 - 管道 - 消息队列 - 管道 - 消费者</p>
<h4 id="consumepy">consume.py</h4>
<pre><code>import pika
import time
def callback(channel, method, properties, body):
   time.sleep(1)
   print(channel,  body)
   channel.basic_ack(delivery_tag=method.delivery_tag)

with pika.BlockingConnection(pika.ConnectionParameters(host='39.107.86.223')) as connection:
    channel = connection.channel()
    queue_name = 'myqueue'
    channel.queue_declare(		# 声明队列
        queue=queue_name,
        durable=True,      # 持久化，但只是队列不消失，队列里面的数据不一定。 durable=True队列持久化
        exclusive=False,    # 只能一个连接使用，并且连接后，队列雄安是
        auto_delete=False,  # 消费者不再使用队列时，自动删除队列
    )
    channel.basic_qos(prefetch_count=10) # 一次性 喂给消费者10条，消费者自己一点一点消费，10条过后，回复确认
    channel.basic_consume(
        queue_name,
        callback,
        auto_ack=False
        # auto_ack 设为 False 就意味着，需要手动回复确认, 需要设置callback里的 channel.basic_ack （默认为False）
            # 收到一条，确认后，再发下一条， 若中断，则 依然从 ack标识处，续传
        # auto_ack 设为 True 就意味着， 系统帮助消费者自动回复确认，即（自动清空 队列中 生产者的数据）
    )
    channel.start_consuming()
</code></pre>
<h4 id="productpy">product.py</h4>
<pre><code>import pika
with pika.BlockingConnection(pika.ConnectionParameters(host='39.107.86.223',port=5672)) as connection:
    channel = connection.channel()
    queue_name = 'myqueue'
    channel.queue_declare(
        queue=queue_name,
        durable=True,      # 持久化，但只是队列不消失，队列里面的数据不一定。 durable=True队列持久化
        exclusive=False,    # 只能一个连接使用，并且连接后，队列雄安是
        auto_delete=False,  # 消费者不再使用队列时，自动删除队列
    )

    for x in range(50):
        channel.basic_publish(
            exchange='',
            routing_key=queue_name,
            body=str(x),
            properties=pika.BasicProperties(
                delivery_mode=2     # 设为2表示，队列里面的 消息 的 持久化
            )
        ) 
</code></pre>
<h1 id="有交换机">有交换机</h1>
<p>基本机制：生产者 - 管道 - routing_key - 交换机 - binding_key - 消息队列 - 管道 - 消费者<br>
生产者不用连接队列，因为被交换机连接。 消费者必须连接队列。</p>
<h3 id="直连交换机-direct-routing_key和-binding_key严格匹配">直连交换机 (direct - routing_key和 binding_key严格匹配)</h3>
<p>注意情况，若binding_key 对应的队列是临时队列， 那么 需要先启动消费者，再启动生产者<br>
如果先启动的是生产者，那么发出到交换机的数据 找不到匹配的消费者， 那么数据就会丢失，因为交换机是临时的</p>
<h4 id="consumepy-2">consume.py</h4>
<pre><code>import pika
import time
def callback(channel, method, properties, body):
    time.sleep(1)
    print(body)
    channel.basic_ack(delivery_tag=method.delivery_tag)

with pika.BlockingConnection(pika.ConnectionParameters(host='39.107.86.223')) as connection:
    channel = connection.channel()
    exchange_name = 'direct'
    channel.exchange_declare(
        exchange_name,
        exchange_type='direct',
        durable=True,      # 持久化，但只是队列不消失，队列里面的数据不一定。 durable=True队列持久化
    )
    queue_name = 'queue'
    channel.queue_declare(queue_name,exclusive=True)  # exclusive 代表当前连接独享队列，队列随着连接消失

    binding_keys = ['debug', 'info', 'warning'] # product的routing_key要包含在这里面
    for binding_key in binding_keys:
        channel.queue_bind(
            queue_name,    # 右连队列
            exchange_name, # 左连交换机
            routing_key=binding_key
        )

    channel.basic_qos(prefetch_count=10) # 一次性 喂给消费者10条，消费者自己一点一点消费，10条过后，回复确认
    channel.basic_consume(
        queue_name,
        callback,
        auto_ack=False
        # auto_ack 设为 False 就意味着，需要手动回复确认, 需要设置callback里的 channel.basic_ack （默认为False）
            # 收到一条，确认后，再发下一条， 若中断，则 依然从 ack标识处，续传
        # auto_ack 设为 True 就意味着， 系统帮助消费者自动回复确认，即（自动清空 队列中 生产者的数据）
    )
    channel.start_consuming()
</code></pre>
<h4 id="productpy-2">product.py</h4>
<pre><code>import pika
with pika.BlockingConnection(pika.ConnectionParameters(host='39.107.86.223',port=5672)) as connection:
    channel = connection.channel()
    exchange_name = 'direct'
    channel.exchange_declare(
        exchange_name,
        exchange_type='direct',
        durable=True,      # 持久化，但只是队列不消失，队列里面的数据不一定。 durable=True队列持久化
    )
    routing_key = 'debug'

    for x in range(50):
        channel.basic_publish(
            exchange=exchange_name,
            routing_key=routing_key,
            body=str(x)
        )
</code></pre>
<h3 id="主题交换机-topic-routing_key和-binding_key模糊匹配">主题交换机 (topic - routing_key和 binding_key模糊匹配)</h3>
<p>基本机制： 和直连基本一样，topic - routing_key和 binding_key 模糊匹配成功后，才能正确通信<br>
代码部分，只修改<br>
exchange_name = 'topic'<br>
exchange_type = 'direct'<br>
其他基本一致， binding_key 改为模糊语法即可<br>
语法格式：<br>
* 匹配一个代词<br>
# 匹配 0个或多个单词<br>
eg:<br>
a.b  可对应为 a.*<br>
a.b.c 可对应为 a.#</p>
<h3 id="扇形交换机-fanout-广播机制">扇形交换机 (fanout -- 广播机制)</h3>
<p>基本机制：开启多个 消费者等待， 然后开启一个生产者，所有队列都会开始消费<br>
简单来说，就是 一个提供数据， 多个队列消费此数据<br>
资源从哪里开始分配，取决于 channel.basic_qos(prefetch_count=10) 的设置</p>
<p>不依赖 routing_key 和 binding_key。<br>
将 exchange_type 改为 fanout</p>
<h4 id="consumepy-3">consume.py</h4>
<pre><code>import pika
import time

def callback(channel, method, properties, body):
    time.sleep(1)
    print(body)
    channel.basic_ack(delivery_tag=method.delivery_tag)

def main():
    with pika.BlockingConnection(pika.ConnectionParameters(host='39.107.86.223')) as connection:
        channel = connection.channel()
        exchange_name = 'fanout'
        channel.exchange_declare(
            exchange_name,
            # exchange_type='direct',
            exchange_type='fanout',
            durable=True,  # 持久化，但只是队列不消失，队列里面的数据不一定。 durable=True队列持久化
        )
        queue_name = 'queue'
        channel.queue_declare(queue_name)  # exclusive 代表当前连接独享队列，队列随着连接消失
        channel.queue_bind(
            queue_name,  # 右连队列
            exchange_name,  # 左连交换机, 注意，因为不依赖 routing_key 和 binding_key ，所以不用写routing_key参数
        )
        channel.basic_qos(prefetch_count=10)  # 一次性 喂给消费者10条，消费者自己一点一点消费，10条过后，回复确认
        channel.basic_consume(
            queue_name,
            callback,
            auto_ack=False
            # auto_ack 设为 False 就意味着，需要手动回复确认, 需要设置callback里的 channel.basic_ack （默认为False）
                # 收到一条，确认后，再发下一条， 若中断，则 依然从 ack标识处，续传
            # auto_ack 设为 True 就意味着， 系统帮助消费者自动回复确认，即（自动清空 队列中 生产者的数据）
        )
        channel.start_consuming()
main()
</code></pre>
<h4 id="productpy-3">product.py</h4>
<pre><code>import pika

def main():
    with pika.BlockingConnection(pika.ConnectionParameters(host='39.107.86.223',port=5672)) as connection:
        channel = connection.channel()
        exchange_name = 'fanout'
        channel.exchange_declare(
            exchange_name,
            exchange_type='fanout',
            durable=True,      # 持久化，但只是队列不消失，队列里面的数据不一定。 durable=True队列持久化
        )
        for x in range(50):
            channel.basic_publish(
                exchange=exchange_name,
                routing_key='',
                body=str(x)
            )
main()</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => Git常用命令/组合套路]]></title>
        <id>https://cythonlin.github.io/post/py-greater-git-chang-yong-ming-ling-zu-he-tao-lu/</id>
        <link href="https://cythonlin.github.io/post/py-greater-git-chang-yong-ming-ling-zu-he-tao-lu/">
        </link>
        <updated>2020-09-29T03:43:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="全部配置个人信息本机所有仓库">全部配置个人信息（本机所有仓库）</h1>
<pre><code>git config --global user.name  &quot;用户名 &quot;
git config --global user.email &quot;邮箱&quot;
</code></pre>
<h1 id="查看个人信息">查看个人信息</h1>
<pre><code>git config --list 
</code></pre>
<h1 id="生成ssh密钥">生成SSH密钥</h1>
<pre><code>ssh-keygen
pub_key - &gt; github
</code></pre>
<h1 id="新建仓库基操五部曲">新建仓库基操五部曲</h1>
<pre><code>git init
git add xxx（添加到缓存区）	  &lt;===互逆===&gt;  git reset HEAD （从缓存区拿回来）
git commit -m '描述信息'
git remote add origin git@github.com:hacker-lin/test.git		# 你的github 仓库克隆地址
git push -u origin master
</code></pre>
<h1 id="开发分支操作n部曲">开发分支操作N部曲</h1>
<p>假如线上有项目，你本地 没有 仓库，那么你就首先需要：<br>
git clone xxx				# 第一次<br>
cd 目录</p>
<pre><code>git checkout -b new_bug    # 创建并切换到新分支
echo new_bug&gt;new_bug		
git add .
git commit -m 'new_bug'

git push -u origin new_bug  # 连接名 分支名 可通过（git remote， git branch）查看
							# 这步的目的是，自己的分支写完也要push保存一下，防止丢失
git checkout master       # 回到主分支
git merge new_bug			# 把 new_bug分支合并到 master 分支
git push					# 将合并完事的master重新推上去 （这样就完事一次产品的迭代）
</code></pre>
<p>假如线上有项目，你本地也有仓库，那么你就不需要git clone了<br>
你只需要 git pull<br>
git pull					# pull等价于 fetch + merge<br>
git checkout -b new_bug01<br>
echo new_bug01 &gt; new_bug01<br>
git add .<br>
git commit -m 'new_bug01'</p>
<pre><code>git push -u origin new_bug01  # 这步的目的是，自己的分支写完也要push保存一下，防止丢失
git checkout master        # 切换到master
git merge new_bug01		    # 把 new_bug01分支合并进来（合并到master）
git push					 # 将合并完事的master重新推上去 （这样就完成又一次产品的迭代）
</code></pre>
<h1 id="区域信息">区域信息</h1>
<pre><code>git status  
	# 未被git add的-（红色）
	# 已经git add的-（绿色）
	# 已经 git commit的-（无信息）
git log		# 查看版本commit历史信息
</code></pre>
<h1 id="分支信息">分支信息</h1>
<pre><code>git branch
</code></pre>
<h1 id="远程连接信息">远程连接信息</h1>
<pre><code>git remote
</code></pre>
<h1 id="删除本地">删除本地</h1>
<pre><code>rm xxxxx
git rm xxxxx
git commit -m '描述'</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => Anaconda-Jupyter相关配置]]></title>
        <id>https://cythonlin.github.io/post/py-greater-anaconda-jupyter-xiang-guan-pei-zhi/</id>
        <link href="https://cythonlin.github.io/post/py-greater-anaconda-jupyter-xiang-guan-pei-zhi/">
        </link>
        <updated>2020-09-29T03:43:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="conda虚拟环境命令">Conda虚拟环境命令</h1>
<h3 id="查看所有虚拟环境2种结果一摸一样">查看所有虚拟环境（2种，结果一摸一样）</h3>
<pre><code>conda info --e
或
conda env list
</code></pre>
<h3 id="创建">创建</h3>
<pre><code>conda create -n rs python=3.8.5
</code></pre>
<h3 id="激活">激活：</h3>
<pre><code>conda activate rs
</code></pre>
<h3 id="退出">退出：</h3>
<pre><code>conda deactivate
</code></pre>
<h3 id="删除虚拟环境">删除虚拟环境：</h3>
<pre><code>conda remove -n rs --all
</code></pre>
<h3 id="查看当前虚拟环境所安装的包">查看当前虚拟环境所安装的包</h3>
<pre><code>conda list
</code></pre>
<h3 id="搜索某包的信息包括channel">搜索某包的信息（包括channel）</h3>
<pre><code>conda search requests
</code></pre>
<h3 id="升级当前conda">升级当前conda</h3>
<pre><code>conda update conda
</code></pre>
<h3 id="查看镜像">查看镜像</h3>
<pre><code>conda config --show channels
</code></pre>
<h3 id="更改镜像">更改镜像</h3>
<pre><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --set show_channel_urls yes
</code></pre>
<h3 id="删除镜像">删除镜像</h3>
<pre><code>conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
</code></pre>
<h3 id="更新-某环境的-某个包">更新 某环境的 某个包</h3>
<p>conda update -n rs requests</p>
<h3 id="删除-某环境-的-某个包">删除 某环境 的 某个包</h3>
<p>conda remove -n rs requests</p>
<h1 id="生成jupyter配置文件">生成Jupyter配置文件</h1>
<pre><code>jupyter notebook --generate-config
</code></pre>
<p>这条命令过后，会提示你 xxx路径下，创建了一个xxx配置文件，记下来。</p>
<h1 id="更换jupyter基目录">更换Jupyter基目录</h1>
<ol>
<li>打开上面的配置文件（windows用Sublime或普通的notebook）（linux用vim即可）</li>
<li>搜索关键词 c.NotebookApp.notebook_dir     # 把后面字符串设成你的路径即可</li>
<li>保存退出，重新打开 Jupyter。</li>
</ol>
<h1 id="调高jupyter的io频率若不调-可能会越界">调高Jupyter的IO频率（若不调 可能会越界）</h1>
<ol>
<li>打开上面的配置文件（windows用Sublime或普通的notebook）（linux用vim即可）</li>
<li>搜索关键词 c.NotebookApp.iopub_data_rate_limit    # 把后面的数字调大（越大越好）</li>
<li>保存退出，重新打开 Jupyter。</li>
</ol>
<h1 id="修改jupyter主题样式">修改Jupyter主题样式</h1>
<p>安装<br>
pip install jupyterthemes     （Anaconda-prompt 的pip）<br>
列出所有样式名称<br>
jt -l<br>
修改样式<br>
jt -t monokai<br>
如果感觉都不好看，可恢复(使用完记得重启jupyter)：<br>
jt -r<br>
别人推荐的样式（主题+字体+界面宽度一气呵成）：<br>
jt -t chesterish -f fira -fs 13 -nf ptsans -nfs 11 -N -kl -cursw 5 -cursc r -cellw 95% -T<br>
官方样式说明：<br>
https://github.com/dunovank/jupyter-themes<br>
或者这篇教程：<br>
https://towardsdatascience.com/bringing-the-best-out-of-jupyter-notebooks-for-data-science-f0871519ca29</p>
<h1 id="jupyter全屏编辑">Jupyter全屏编辑</h1>
<p>这个我之前查过，修改配置文件的都不好用<br>
（上面改主题的时候可以该宽度，但貌似必须修改主题，才能修改界面宽度，否则不可以）</p>
<p>只在StackOverflow上找到了一种简陋的解决办法<br>
每个ipynb文件头部加上固定的2条语句即可：<br>
from IPython.core.display import display, HTML<br>
display(HTML(&quot;<style>.container { width:100% !important; }</style>&quot;))</p>
<h1 id="有趣的扩展不是很实用">有趣的扩展（不是很实用）</h1>
<p>内嵌dataframe表格操作: （玩玩可以，慎用， 小型数据就撑不住了，导致整个kernel崩溃）<br>
安装：<br>
pip install qgrid<br>
jupyter nbextension enable --py --sys-prefix qgrid<br>
导入：<br>
from qgrid import show_grid as s<br>
使用案例：<br>
df = pd.DataFrame([['bac', 'bcd'],['应用','博客']])<br>
s(df, show_toolbar=True)<br>
结果如下:<br>
笔记无法插入本地图片。。。。。。很易懂的结果。</p>
<p>内嵌小浏览器：<br>
from IPython.display import IFrame<br>
IFrame('https://www.baidu.com/s?ie=UTF-8&amp;wd=fsd', width=1200, height=1000)</p>
<h1 id="conda各种疑难杂症安装">Conda各种疑难杂症安装</h1>
<p>所有包几乎都可以用 Anaconda-prompt 中的 pip，这种 安装方法是&quot;下下策&quot;。<br>
因为有时用这个装可能出问题。</p>
<h3 id="opencv">Opencv</h3>
<p>conda:<br>
conda install -c menpo opencv<br>
pip:<br>
pip install opencv-python</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => 超级鹰打码（Python）+报错回扣]]></title>
        <id>https://cythonlin.github.io/post/py-greater-chao-ji-ying-da-ma-pythonbao-cuo-hui-kou/</id>
        <link href="https://cythonlin.github.io/post/py-greater-chao-ji-ying-da-ma-pythonbao-cuo-hui-kou/">
        </link>
        <updated>2020-09-29T03:41:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="细微如下改动">细微如下改动</h1>
<ol>
<li>兼容Python3</li>
<li>1元包调试试用（8001） 4-6位 英文+数字验证码</li>
<li>打码与预期结果不符，调用报错提示，将图片ID传回，可将失误次数返回</li>
<li>代码对照表如下<br>
https://www.chaojiying.com/price.html</li>
</ol>
<h1 id="脚本代码如下">脚本代码如下</h1>
<pre><code>import requests
from hashlib import md5

class Chaojiying_Client(object):

    def __init__(self, username, password, soft_id):
        self.username = username
        password =  password.encode('utf8')
        self.password = md5(password).hexdigest()
        self.soft_id = soft_id
        self.base_params = {
            'user': self.username,
            'pass2': self.password,
            'softid': self.soft_id,
     }
        self.headers = {
            'Connection': 'Keep-Alive',
            'User-Agent': 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)',
        }

    def PostPic(self, im, codetype):
        &quot;&quot;&quot;
        im: 图片字节
     codetype: 题目类型 参考 http://www.chaojiying.com/price.html
     &quot;&quot;&quot;
		params = {
         'codetype': codetype,
        }
        params.update(self.base_params)
        files = {'userfile': ('ccc.jpg', im)}
   	 r = requests.post('http://upload.chaojiying.net/Upload/Processing.php', data=params, files=files, headers=self.headers)
    	return r.json()

	def ReportError(self, im_id):
        &quot;&quot;&quot;
     im_id:报错题目的图片ID
     &quot;&quot;&quot;
        params = {
         'id': im_id,
     }
     params.update(self.base_params)
     r = requests.post('http://upload.chaojiying.net/Upload/ReportError.php', data=params, headers=self.headers)
     return r.json()


if __name__ == '__main__':
 chaojiying = Chaojiying_Client('你的用户名', '你的密码', '软件ID')	 # 进入主页-&gt;软件ID -&gt; 生成一个软件ID（上面小字）
	im = open('a.jpg', 'rb').read()												
	result = chaojiying.PostPic(im, 8001)											
	print(result)
	if result['pic_str'] != 'n1wtu':
        print(chaojiying.ReportError(result['pic_id']))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => import_module 和 __import__ 区别]]></title>
        <id>https://cythonlin.github.io/post/py-greater-import_module-he-__import__-qu-bie/</id>
        <link href="https://cythonlin.github.io/post/py-greater-import_module-he-__import__-qu-bie/">
        </link>
        <updated>2020-09-29T03:41:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题引入原因">问题引入原因</h1>
<h4 id="今天用反射写配置时发现-import-不能将多级模块导入而import_module可以">今天用反射写配置时，发现 <strong>import</strong>() 不能将多级模块导入，而import_module可以</h4>
<h1 id="案例一-我最开始接触就是这么测试用法的">案例一 (我最开始接触就是这么测试用法的。。)</h1>
<h3 id="_import_">_<em>import</em>_</h3>
<pre><code>random = __import__('random')
random.randint()
# 正常运行
</code></pre>
<h3 id="import_module">import_module</h3>
<pre><code>from importlib import import_module
random = import_module('random')
random.randint()
# 正常运行
</code></pre>
<h1 id="案例二">案例二</h1>
<h3 id="_import_-2">_<em>import</em>_</h3>
<pre><code>parse = __import__('urllib.parse')
parse.urlencode('a=1')
# 报错：module 'urllib' has no attribute 'urlencode'
</code></pre>
<h3 id="import_module-2">import_module</h3>
<pre><code>from importlib import import_module
parse = import_module('urllib.parse')
parse.urlencode({'a':1})
# 正常运行
</code></pre>
<h1 id="分析">分析</h1>
<h4 id="1-通过导入的-from-importlib-import-_import_-和-内建函数-_import_-我都试过他俩的作用是一样的">1. 通过导入的 from importlib import _<em>import</em>_ 和 内建函数 _<em>import</em>_ 我都试过，他俩的作用是一样的</h4>
<h4 id="2-_import_-参数只能写一个单词模块-如果写成形如-aabbcc-它只会导入-aa">2. _<em>import</em>_()  参数只能写一个单词模块， 如果写成形如 aa.bb.cc， 它只会导入 aa</h4>
<h4 id="2-import_module-它的用法就很合人意了-里面写啥他就会像-import-一样都导入进来">2. import_module()  它的用法就很合人意了。 里面写啥他就会像 import 一样都导入进来</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => Celery使用记录]]></title>
        <id>https://cythonlin.github.io/post/py-greater-celery-shi-yong-ji-lu/</id>
        <link href="https://cythonlin.github.io/post/py-greater-celery-shi-yong-ji-lu/">
        </link>
        <updated>2020-09-29T03:40:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前置环境">前置环境</h1>
<pre><code>pip install redis
pip install gevent
</code></pre>
<h1 id="configpy">config.py</h1>
<pre><code>broker_url = 'redis://ip/0'
result_backend = 'redis://ip/1'	# tasks返回结果存储地址
result_expires = 10 * 60	# 过期时间
imports = ('tasks')
</code></pre>
<h1 id="taskspy">tasks.py</h1>
<pre><code>import requests
from celery import Celery

app = Celery()
app.config_from_object('config')

@app.task(ignore_result=False)
def crawl(url):
    response = requests.get(url)
    return {'data': response.text}	# 返回并储存的结果
</code></pre>
<h1 id="spiderpy">spider.py</h1>
<pre><code>import tasks

def main(url_list):
	for per_url in url_list:
	tasks.crawl.delay(per_url)
    
if __name__ == '__main__':
	main(
		['http://www.baidu.com','http://www.douyu.com/']
	)
</code></pre>
<h1 id="workerpy">worker.py</h1>
<pre><code>import os
os.system('celery worker -A tasks  -l info -P gevent')
	# -A tasks    即为 tasks.py对应模块
	# -P gevent   即为异步指定环境为 gevent
</code></pre>
<h1 id="使用">使用</h1>
<p>先执行 spider.py 将任务存入到redis队列中，<br>
然后执行 worker.py，正式启动任务</p>
<h1 id="总结">总结</h1>
<p>celery 大体分为 3种 模块<br>
task ：  专门定义函数，用装饰器装饰作为一个任务（类似于flask的视图）<br>
broker： 中间人队列，存储任务  （例如 rabbitmq, redis等）<br>
worker： 从broker队列拿出任务来 正式运行 （可多个）</p>
<h1 id="相关配置参数参考地址">相关配置参数参考地址</h1>
<p>https://www.cnblogs.com/cwp-bg/p/8759638.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => 自编魔法"鬼"句]]></title>
        <id>https://cythonlin.github.io/post/py-greater-zi-bian-mo-fa-gui-ju/</id>
        <link href="https://cythonlin.github.io/post/py-greater-zi-bian-mo-fa-gui-ju/">
        </link>
        <updated>2020-09-29T03:38:58.000Z</updated>
        <content type="html"><![CDATA[<p>鬼句1：<br>
女朋友 = type('A',(), {'<strong>eq</strong>': lambda _,<strong>: 'True' if  _ is not __ else 'False', '<strong>ne</strong>': lambda _,</strong>: 'True' if  _ is __ else 'False'})()<br>
天使 = type('天使')</p>
<pre><code>print(女朋友 == 女朋友)
print(女朋友 != 女朋友)
print(女朋友 == 天使)
print(女朋友 != 天使)
</code></pre>
<p>鬼句2：数列<br>
import math</p>
<pre><code>数列 = type('数列', (), {'__getitem__': lambda self,_: list(range(_[0], _[4]+1, _[1]-_[0])) if _[1]-_[0]==_[2]-_[1] else (lambda a1,e:  [a1 * e**(_) for _ in range(0,int(math.log(_[4]/a1, e))+1)])(_[0],_[1]/_[0])})()

print(数列[1,3,9,...,729])
print(数列[1,3,5,...,21])</code></pre>
]]></content>
    </entry>
</feed>