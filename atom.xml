<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cythonlin.github.io</id>
    <title>Cython_lin</title>
    <updated>2021-03-06T05:18:13.125Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cythonlin.github.io"/>
    <link rel="self" href="https://cythonlin.github.io/atom.xml"/>
    <logo>https://cythonlin.github.io/images/avatar.png</logo>
    <icon>https://cythonlin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Cython_lin</rights>
    <entry>
        <title type="html"><![CDATA[IDE => My Sublime（PY）]]></title>
        <id>https://cythonlin.github.io/post/ide-greater-my-sublimepy/</id>
        <link href="https://cythonlin.github.io/post/ide-greater-my-sublimepy/">
        </link>
        <updated>2021-03-03T07:17:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="fc">FC</h1>
<pre><code>#00FFFF
0,255,255
</code></pre>
<h1 id="package-control">package control</h1>
<h2 id="package-control报错">package control报错</h2>
<p>😒No module named 'package_control'<br>
进入preferences &gt;settings： 删除列表中的 &quot;0_package_control_loader&quot; 即可。<br>
最终保留内容为：</p>
<pre><code>[
	&quot;0_package_control_loader&quot;,
	&quot;Vintage&quot;
],
</code></pre>
<h1 id="主题">主题</h1>
<h2 id="首先安装一个包管理插件">首先安装一个包管理插件</h2>
<p>因为Sublime Text3 一些配置被压缩了，通过这个插件可以直接查看内部设置</p>
<pre><code>PackageResourceViewer
</code></pre>
<p>安装后， ctrl+shift+p，输入 prv (记住这个后续修改侧边栏之类的会用到)</p>
<h2 id="安装">安装</h2>
<p>ctrl+shift+P<br>
material theme</p>
<pre><code># 安装后再次 ctrl+shift+p
    # 激活： 输入ma （material-theme-darker）
    # 配置： 输入mc （配置color scheme: 选 material-theme）
</code></pre>
<p>mc 的 tabs 的如下选项勾上（后3个）：</p>
<ul>
<li>material_theme_small_tab</li>
<li>material_theme_tabs_autowidth</li>
<li>material_theme_tabs_separator</li>
</ul>
<p>mc 的 sidebar 的如下选项 勾上（第4个和第5个）：</p>
<ul>
<li>material_theme_compact_sidebar</li>
<li>material_theme_disable_fileicons</li>
</ul>
<h2 id="修改代码区字体类型和字体大小">修改代码区字体类型和字体大小</h2>
<p>preference -&gt; settings</p>
<pre><code>&quot;font_face&quot;: &quot;Courier New&quot;,
&quot;font_size&quot;: 14,
</code></pre>
<h2 id="修改侧边栏后者顶部tab等配置">修改侧边栏，后者顶部tab等配置</h2>
<p>由于st3的配置文件被压缩，所以我们上面安装PackageResourceViewer，就是为了打开压缩的配置</p>
<ul>
<li>输入 prvo （就是 PackageResourceViewer open resource）</li>
<li>再输入  mt（就是 material theme ）</li>
<li>再输入 mtst （就是 material-theme.sublime-theme ）</li>
<li>此时你会看到打开了一个配置文件，接下来再配置文件修改即可👇</li>
</ul>
<h3 id="修改顶部tab">修改顶部tab</h3>
<p>搜索字样：// Tab Labels， 找到 font.size<br>
😶（一个有2个 // tab Labels， 找到有 font.size的才是）：</p>
<pre><code>  &quot;fg&quot;: [255, 255, 255],
  &quot;font.size&quot;: 19,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<p>搜索字样：// Tab selected label color， 修改fg如下：</p>
<pre><code>&quot;fg&quot;: [0,255,255, 255],
</code></pre>
<p>搜索字样：// Status bar labels  （感觉status bar占地方，就view =&gt; hide status bar）</p>
<pre><code>&quot;color&quot;: [0, 255, 255, 100],
</code></pre>
<p>搜索字样：tool_tip_label_control</p>
<p>搜索字样：quick_panel_label （从上到下，第一个即可）</p>
<pre><code>  &quot;font.size&quot;: 23,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<p>搜索字样：quick_panel_path_label</p>
<pre><code>  &quot;font.size&quot;: 18,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<p>搜索字样：quick_panel_score_label</p>
<pre><code>  &quot;font.size&quot;: 18,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<h3 id="修改侧边栏">修改侧边栏</h3>
<p>找到 sidebar_label ， 并添加：</p>
<pre><code>  &quot;font.bold&quot;: true,
  &quot;color&quot;: [200, 125, 0, 200],
  &quot;font.size&quot;: 18,
</code></pre>
<h1 id="添加编译环境">添加编译环境</h1>
<h2 id="普通编译基本不用配ctrlb激活">普通编译（基本不用配，ctrl+b激活）</h2>
<p>Tools =&gt; build system =&gt; new build system 输入如下内容 =&gt; 保存文件到目录</p>
<pre><code>{
    &quot;cmd&quot;: [&quot;python&quot;, &quot;-u&quot;, &quot;$file&quot;],
    &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,
}
</code></pre>
<p>上面cmd内第一个参数写python.exe路径也可以<br>
😊然后就可一选择并使用了： Tools =&gt; build system =&gt; python (ctrl+b)</p>
<h2 id="删除编译的打印错误路径日志">删除编译的打印错误路径日志</h2>
<p>上面已经安装过了，这里就不再安装了，直接面板输入 prvo =&gt; 输入default =&gt; 输入 exec.py<br>
搜索字样：if &quot;PATH&quot; in merged_env:<br>
😎注释如下信息：</p>
<pre><code># if shell_cmd:
#     self.debug_text += &quot;[shell_cmd: &quot; + shell_cmd + &quot;]\n&quot;
# else:
#     self.debug_text += &quot;[cmd: &quot; + str(cmd) + &quot;]\n&quot;
# self.debug_text += &quot;[dir: &quot; + str(os.getcwd()) + &quot;]\n&quot;
# if &quot;PATH&quot; in merged_env:
#     self.debug_text += &quot;[path: &quot; + str(merged_env[&quot;PATH&quot;]) + &quot;]&quot;
# else:
#     self.debug_text += &quot;[path: &quot; + str(os.environ[&quot;PATH&quot;]) + &quot;]&quot;
</code></pre>
<h1 id="keys">Keys</h1>
<p>preference =&gt; key bindings</p>
<h2 id="显示隐藏-工具菜单">显示隐藏 工具菜单</h2>
<pre><code>{&quot;keys&quot;: [&quot;ctrl+m&quot;], &quot;command&quot;: &quot;toggle_menu&quot;},
</code></pre>
<h2 id="取消编译">取消编译</h2>
<pre><code>{ &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;cancel_build&quot; }
</code></pre>
<h2 id="显示隐藏侧边栏">显示/隐藏侧边栏</h2>
<pre><code>{ &quot;keys&quot;: [&quot;ctrl+k&quot;], &quot;command&quot;: &quot;toggle_side_bar&quot; },
</code></pre>
<h2 id="代码块折叠展开默认的即可">代码块折叠/展开(默认的即可)</h2>
<pre><code>默认为  ctrl + shift + [  ]
</code></pre>
<h2 id="各种搜索快捷键">各种搜索快捷键</h2>
<p>😄代码搜索（最好用）：</p>
<pre><code>ctrl + p

有几种用法：
1. 直接输入内容，表示查找文件名
2. @函数名，表示查找函数名。eg  @write_file
3. :数字n ，表示跳转到第n行。 eg  :65
4. #变量名， 表示查找变量名。eg   #name
</code></pre>
<p>文本搜索</p>
<pre><code>ctrl + f
</code></pre>
<p>多文件搜索<br>
😶注意：也许pycharm不需要关闭繁体也能用，但是sublime必须关繁体切换才能用此key</p>
<pre><code>ctrl + shift + f
</code></pre>
<p>替换(默认的即可)</p>
<pre><code>ctrl + H
</code></pre>
<h2 id="选择括号内的内容默认即可">选择括号内的内容(默认即可)</h2>
<pre><code>ctrl + shift + m
</code></pre>
<h2 id="切换标签页">切换标签页</h2>
<pre><code>ctrl + page up / page down
或者 alt + 1  alt + 2   .............
后者 ctrl + tab
</code></pre>
<h2 id="创建新标签页新文件">创建新标签页/新文件</h2>
<pre><code>ctrl + n
</code></pre>
<h2 id="创建新sublime窗口">创建新sublime窗口</h2>
<pre><code>ctrl + shift + n
</code></pre>
<h2 id="窗口并排">窗口并排</h2>
<pre><code>alt + shift + 1     // 1排
alt + shift + 2     // 2排
alt + shift + 3     // 3排
alt + shift + 4     // 4排
</code></pre>
<h1 id="plugins">Plugins</h1>
<h2 id="语言插件不建议使用">语言插件（不建议使用）</h2>
<pre><code>localizeMenu
</code></pre>
<h2 id="路径提示">路径提示</h2>
<pre><code>autofilename		# 文件路径提示
</code></pre>
<h2 id="侧边栏选项增强">侧边栏选项增强</h2>
<pre><code>sidebarenhancements
</code></pre>
<p>快捷键配置：</p>
<pre><code>{ &quot;keys&quot;: [&quot;delete&quot;], &quot;command&quot;: &quot;side_bar_delete&quot; },
{ &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_rename&quot; },
{ &quot;keys&quot;: [&quot;ctrl+shift+x&quot;], &quot;command&quot;: &quot;side_bar_move&quot; },

// { &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;side_bar_copy&quot; },
// { &quot;keys&quot;: [&quot;ctrl+shift+v&quot;], &quot;command&quot;: &quot;side_bar_paste&quot; },
</code></pre>
<h2 id=""></h2>
<pre><code>alignment
</code></pre>
<h2 id="anaconda">Anaconda</h2>
<p>package settings -&gt; anaconda -&gt; settings user<br>
😊加入下面的配置，可以起到语法格式化的作用（保存ctrl+s后自动格式化）</p>
<pre><code>{
    &quot;python_interpreter&quot;: &quot;D:/python391/python.exe&quot;,
    &quot;auto_formatting&quot;: true,
    &quot;autoformat_ignore&quot;:
        [
            &quot;E309&quot;,
            &quot;E501&quot;
        ],
    &quot;pep8_ignore&quot;:
        [
            &quot;E309&quot;,
            &quot;E501&quot;
        ],
    &quot;anaconda_linting&quot;:false,
        
    &quot;anaconda_linter_underlines&quot;: false,
    &quot;anaconda_linter_mark_style&quot;: &quot;None&quot;,
    &quot;display_signatures&quot;: false,   // 这是函数内部帮助文档提示，我不需要，设false
    // &quot;disable_anaconda_completion&quot;: true  //不能打开它, 打开它anaconda就没有意义了
    // &quot;swallow_startup_errors&quot;: true    // 若anaconda报错，则打开它，否则不用
}
</code></pre>
<p>代码跳转快捷键为默认 ctrl + alt + g</p>
<h2 id="sublimerepl">sublimeREPL</h2>
<pre><code>直接搜 sublimeREPL 安装

tools =&gt; sublimeREPL
</code></pre>
<h2 id="terminal插件">Terminal插件:</h2>
<p>😶打开当前文件所在Terminal<br>
preference =&gt; package settings =&gt; Terminal =&gt; Setting Users<br>
我的是Windows Terminal</p>
<pre><code>{

&quot;keys&quot;: [&quot;ctrl+shift+t&quot;],
&quot;terminal&quot;: &quot;C:/Users/lin/AppData/Local/Microsoft/WindowsApps/wt.exe&quot;,
&quot;parameters&quot;: [&quot;-d&quot;, &quot;.&quot;]
}
</code></pre>
<p><a href="https://github.com/wbond/sublime_terminal">=&gt; terminal官档，也有其他OS版配置</a></p>
<h1 id="vs-code">VS code</h1>
<h2 id="倒叙说明">倒叙说明</h2>
<p>VSC频繁宕掉，已卸载😀，还是Pycharm+Sulime+Jupyter+Miniconda了</p>
<h2 id="中文语言">中文语言</h2>
<pre><code>ctrl + shift + p
输入 language display， 点击，左侧选择安装中文语言
</code></pre>
<h2 id="配置默认终端">配置默认终端</h2>
<p>修改控制台字体(不然PS7 和 WSL 的ZSH图标显示不出来)</p>
<pre><code>右下角 ⚙ 配置
     =&gt; 搜索 terminal font
          =&gt; 将 terminal font family 写入=&gt;  Hack NF
</code></pre>
<p>修改默认Terminal</p>
<pre><code>😀 ctrl +~    调出控制台
下拉菜单选择， 配置默认终端， 选择PS7即可。
然后关闭 终端
重新 按  ctrl +~  ， 再次打开终端即为 PS7
</code></pre>
<h2 id="快捷键">快捷键</h2>
<p>调出控制台</p>
<pre><code>ctrl + ~
</code></pre>
<p>打开命令面板（和 sublime差不多）</p>
<pre><code>ctrl + shift + p
</code></pre>
<h2 id="插件">插件</h2>
<p>python:</p>
<pre><code>vs右侧有，会推荐给你语言插件，直接点python即可
</code></pre>
<p>pylint（语法高亮提示）:</p>
<pre><code>新建py文件运行，他会自动提示你安装pylint
</code></pre>
<p>Python snippets（不建议用）</p>
<pre><code>代码块补全
</code></pre>
<p>sublime keymap and settings importer</p>
<pre><code>sublime式
</code></pre>
<p>remote WSL</p>
<pre><code>可以打开WSL环境的Vscode
</code></pre>
<p>remote SSH</p>
<pre><code>ssh
</code></pre>
<p>remote containers</p>
<pre><code>docker
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 9]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-9/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-9/">
        </link>
        <updated>2021-03-03T07:17:35.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 9</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 8]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-8/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-8/">
        </link>
        <updated>2021-03-03T07:17:23.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 8</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 7]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-7/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-7/">
        </link>
        <updated>2021-03-03T07:17:07.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 7</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 6]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-6/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-6/">
        </link>
        <updated>2021-03-03T07:16:52.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 6</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 5]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-5/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-5/">
        </link>
        <updated>2021-03-03T07:16:35.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 5</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 4]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-4/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-4/">
        </link>
        <updated>2021-03-03T07:16:02.000Z</updated>
        <content type="html"><![CDATA[<p>ING..........</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 3]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-3/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-3/">
        </link>
        <updated>2021-03-03T07:15:39.000Z</updated>
        <content type="html"><![CDATA[<p>ING..........</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 2]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-2/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-2/">
        </link>
        <updated>2021-03-03T07:15:16.000Z</updated>
        <content type="html"><![CDATA[<p>ing.......</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GO => Golang复习（未完待续）]]></title>
        <id>https://cythonlin.github.io/post/rs-greater/</id>
        <link href="https://cythonlin.github.io/post/rs-greater/">
        </link>
        <updated>2021-03-03T07:10:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="env">ENV</h1>
<h3 id="goroot-默认go安装根目录即可">GOROOT: 默认go安装根目录即可</h3>
<pre><code>D:\code\go
</code></pre>
<h3 id="gopath工程目录里面有bin-pkg-src">GOPATH：工程目录（里面有bin, pkg, src）</h3>
<pre><code>D:\code\go\work
    # 我们只需用goland 去 open src目录即可
</code></pre>
<h3 id="gobingopath里面的bin目录">GOBIN：GOPATH里面的bin目录</h3>
<p>作用： go install 生成的exe 会自动存到这里</p>
<pre><code>D:\code\go\work\bin
</code></pre>
<p>此外我们还需将此目录放入到环境变量，随时随地exe执行</p>
<h3 id="go111module">GO111MODULE</h3>
<pre><code>off ：无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。
on ：模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。
auto ：在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。
</code></pre>
<h1 id="平台go命令">平台+Go命令</h1>
<h2 id="查看go的环境变量">查看GO的环境变量</h2>
<pre><code>go env | grep GOOS
go env | grep GOARCH
</code></pre>
<p>GOOS变量值是什么平台，编译后的文件就只能在什么平台运行</p>
<h2 id="windows">windows:</h2>
<pre><code> go build .\hello.go
.\hello.exe
</code></pre>
<p>Goland terminal修改GOOS</p>
<pre><code>cmd: set GOOS=linux
ps:    $env:GOOS=&quot;linux&quot;
# go env | grep GOOS   # 此时已变为linux

go build .\hello.go
.\hello
# 😴 执行失败，平台不兼容
</code></pre>
<h2 id="linux">linux:</h2>
<pre><code>./hello 执行成功
./hello.exe    执行成功 （纯Linux是会执行失败的，但是这是WSL）
# WSL特殊，因为WSL可以兼容执行windows exe的格式
</code></pre>
<h2 id="go-install">go install</h2>
<p>把目录下 go build 编译后的 exe文件，自动添加到 GOBIN目录下</p>
<pre><code># 需要把上面的环境变量配置好：GO111MODULE auto
go install
</code></pre>
<h1 id="赋值">赋值</h1>
<pre><code>:=       (python3.8也出了，不过，其用途是 条件赋值一体化)
</code></pre>
<p>特殊：空赋值（定义后可不使用，也不能使用）： _</p>
<pre><code>a := 1    // a必须在下文使用
_,b := 1,2  // 必须在下文使用
// _,_ := 1,2  // 这种写法是错误的
_,_ = 1,2   // 当有所有变量都是空变量的时候， 用 = 即可，而不是用:=
</code></pre>
<h1 id="真假">真假</h1>
<p>只有 true/false<br>
不能使用 0 &quot;&quot; 之类的数据来代替真假（py可以， if 1:pass）</p>
<h1 id="i">i++</h1>
<p>go: 只有 i++ 和 i+= ,  且只能单独放一行 (i-- 和 i-= 也是可以的)<br>
py: 只有 i+=</p>
<h1 id="交换变量的四种方式">交换变量的四种方式</h1>
<p>下面代码，除了数据声明与定义，其他Py 和 Go 的语法都是一摸一样的（主要强调 异或方式）<br>
a := 1<br>
b := 3</p>
<h3 id="方式0">方式0</h3>
<pre><code>c := 0
c = a
a = b
b = c
</code></pre>
<h3 id="方式1">方式1</h3>
<pre><code>a,b = b,a
</code></pre>
<h3 id="方式2">方式2</h3>
<pre><code>a = a + b
b = a - b
a = a - b
</code></pre>
<h3 id="方式3-注必须是整形-py也一样">方式3 （注：必须是整形， Py也一样）</h3>
<pre><code>a = a ^ b
b = a ^ b
a = a ^ b

fmt.Println(a)
fmt.Println(b)
</code></pre>
<h1 id="string">string</h1>
<p>原生字符串输入：</p>
<pre><code>python &quot;&quot;&quot; &quot;&quot;&quot;
golang ` `          反引号
</code></pre>
<p>python和golang都是内部不可变，外部可变（可以整体替换赋值）<br>
都有 len()</p>
<h1 id="数组">数组</h1>
<h2 id="定长创建">定长创建</h2>
<p>方式1</p>
<pre><code>arr1 := [3]int{1,2,3}
</code></pre>
<p>方式2</p>
<pre><code>var arr2 [3]int
arr2 = [3]int{1,2,3}
fmt.Println(arr1)
fmt.Println(arr2)
</code></pre>
<h2 id="非定长创建">非定长创建</h2>
<pre><code>arr1 := []int{1,2,3}
</code></pre>
<p>append:</p>
<pre><code>arr1 = append(arr1, 4)
</code></pre>
<p>len:</p>
<pre><code>len(arr1)
</code></pre>
<p>😏cap:</p>
<pre><code>arr1 := []int{1,2,3}
fmt.Println(len(arr1),cap(arr1))      // 3,3
arr1 = append(arr1, 4,5)	  // 5,6  
fmt.Println(len(arr1),cap(arr1))
</code></pre>
<p>len()的变化是没什么好说的<br>
cap() 首先 arr1的只有3个元素，容量就分了3个（满了）<br>
既然满了，那就append一个元素，开一个空间？这太费劲了。<br>
于是 go 会在你每次元素容量溢出的时候，为你😊2倍扩容。</p>
<p>😑注意0，不足1024，2倍扩容。 超过1024，1.25倍扩容。<br>
😑注意1，这个二倍是在现有的容量进行2倍扩容。 eg:</p>
<pre><code>3 * 2 = 6
6 * 2 = 12
...
</code></pre>
<p>😊特别注意<br>
如果是用 for 循环的方式append （）</p>
<pre><code>那么你给多少长度，他就会给你扩充至多少。
😊虽然最后一次遍历输出看起来 len 和 cap 趋近相等
😊但是每一次循环的过程，还是采用 二倍扩容原则！！！
</code></pre>
<p>eg:</p>
<pre><code>arr1 := []int{1,2,3}
fmt.Println(len(arr1),cap(arr1))      // 3,3
for i := 0; i &lt; 92; i++ {
	arr1 = append(arr1, i)
}
fmt.Println(len(arr1),cap(arr1))      // 95, 96
arr1 = append(arr1, 1,2,3,4,5) // 我们的容量只有96，所以越界了，2倍
fmt.Println(len(arr1),cap(arr1))      // 96, 192
</code></pre>
<h2 id="遍历">遍历</h2>
<p>方式1：</p>
<pre><code>for i, v := range arr2 {    // 和python一样 v只是copy的值，并不能用v改变数组
	fmt.Println(i,v)           // index,  value
}
// fmt.Println(i,v)    // 报错 , 因为上面的 i, v 都是临时变量， python则体外可用
</code></pre>
<p>😎Note: Go的 i,和v都是临时面两<br>
方式2：</p>
<pre><code>for i := 0; i &lt; len(arr2); i++ {
	fmt.Println(i,arr2[i])
}
</code></pre>
<h1 id="切片">切片</h1>
<h2 id="认知">认知</h2>
<p>和python一样，都是左闭右开</p>
<pre><code>arr1 := []int{1,2,3,4,5,6,7}
slice1 := arr1[2:5]
fmt.Println(slice1)
</code></pre>
<h2 id="使用方式">使用方式</h2>
<pre><code>[:n]
[m:]
</code></pre>
<p>数组转切片：<br>
// 这个和python截然相反，go意味着数组转切片，完全引用（指针），py表示浅拷贝<br>
[:]</p>
<h2 id="原理">原理</h2>
<p>切片就是数组的部分引用（指针）（2者都是互相，牵一发而动全身，）<br>
😣这点和python完全相反（python 切出来就是新地址了）</p>
<h2 id="创建指定空切片长度len容量cap">创建指定空切片,长度len+容量cap</h2>
<p>好处：一次性分配，成本开销低。</p>
<pre><code>str2 := make([]string, 0, 20)      // 如果不指定cap, 则默认与len一致
fmt.Println(len(str2), cap(str2))  // len=0, cap=20
</code></pre>
<h2 id="浅拷贝">浅拷贝</h2>
<p>copy(新，旧) ， 二者必须都是切片类型 （数组转切片上面说了 [:]）</p>
<pre><code>arr1 := [5]int{1,2,3,4,5}
slice1 := make([]int, len(arr1))
copy(slice1, arr1[:])  // arr1必须转切片， arr1[:]
fmt.Println(slice1)
</code></pre>
<h1 id="if">if</h1>
<p>无小括号</p>
<h1 id="for">for</h1>
<p>无小括号</p>
<h1 id="指针">指针</h1>
<p>GC自动回收，不需要手动回收(py可 del 动态回收)</p>
<h2 id="new">new</h2>
<pre><code>name := new(string) // new出来的就地址
*name = &quot;zhangsan&quot;</code></pre>
]]></content>
    </entry>
</feed>