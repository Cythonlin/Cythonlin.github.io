<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cythonlin.github.io</id>
    <title>Cython_lin</title>
    <updated>2021-03-15T06:59:19.312Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cythonlin.github.io"/>
    <link rel="self" href="https://cythonlin.github.io/atom.xml"/>
    <logo>https://cythonlin.github.io/images/avatar.png</logo>
    <icon>https://cythonlin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Cython_lin</rights>
    <entry>
        <title type="html"><![CDATA[IDE => My Sublime（PY）]]></title>
        <id>https://cythonlin.github.io/post/ide-greater-my-sublimepy/</id>
        <link href="https://cythonlin.github.io/post/ide-greater-my-sublimepy/">
        </link>
        <updated>2021-03-03T07:17:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="fc">FC</h1>
<pre><code>#00FFFF
0,255,255
</code></pre>
<h1 id="package-control">package control</h1>
<h2 id="package-control报错">package control报错</h2>
<p>😒No module named 'package_control'<br>
进入preferences &gt;settings： 删除列表中的 &quot;0_package_control_loader&quot; 即可。<br>
最终保留内容为：</p>
<pre><code>[
	&quot;0_package_control_loader&quot;,
	&quot;Vintage&quot;
],
</code></pre>
<h1 id="主题">主题</h1>
<h2 id="首先安装一个包管理插件">首先安装一个包管理插件</h2>
<p>因为Sublime Text3 一些配置被压缩了，通过这个插件可以直接查看内部设置</p>
<pre><code>PackageResourceViewer
</code></pre>
<p>安装后， ctrl+shift+p，输入 prv (记住这个后续修改侧边栏之类的会用到)</p>
<h2 id="安装">安装</h2>
<p>ctrl+shift+P<br>
material theme</p>
<pre><code># 安装后再次 ctrl+shift+p
    # 激活： 输入ma （material-theme-darker）
    # 配置： 输入mc （配置color scheme: 选 material-theme）
</code></pre>
<p>mc 的 tabs 的如下选项勾上（后3个）：</p>
<ul>
<li>material_theme_small_tab</li>
<li>material_theme_tabs_autowidth</li>
<li>material_theme_tabs_separator</li>
</ul>
<p>mc 的 sidebar 的如下选项 勾上（第4个和第5个）：</p>
<ul>
<li>material_theme_compact_sidebar</li>
<li>material_theme_disable_fileicons</li>
</ul>
<h2 id="修改代码区字体类型和字体大小">修改代码区字体类型和字体大小</h2>
<p>preference -&gt; settings</p>
<pre><code>&quot;font_face&quot;: &quot;Courier New&quot;,
&quot;font_size&quot;: 14,
</code></pre>
<h2 id="修改侧边栏后者顶部tab等配置">修改侧边栏，后者顶部tab等配置</h2>
<p>由于st3的配置文件被压缩，所以我们上面安装PackageResourceViewer，就是为了打开压缩的配置</p>
<ul>
<li>输入 prvo （就是 PackageResourceViewer open resource）</li>
<li>再输入  mt（就是 material theme ）</li>
<li>再输入 mtst （就是 material-theme.sublime-theme ）</li>
<li>此时你会看到打开了一个配置文件，接下来再配置文件修改即可👇</li>
</ul>
<h3 id="修改顶部tab">修改顶部tab</h3>
<p>搜索字样：// Tab Labels， 找到 font.size<br>
😶（一个有2个 // tab Labels， 找到有 font.size的才是）：</p>
<pre><code>  &quot;fg&quot;: [255, 255, 255],
  &quot;font.size&quot;: 19,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<p>搜索字样：// Tab selected label color， 修改fg如下：</p>
<pre><code>&quot;fg&quot;: [0,255,255, 255],
</code></pre>
<p>搜索字样：// Status bar labels  （感觉status bar占地方，就view =&gt; hide status bar）</p>
<pre><code>&quot;color&quot;: [0, 255, 255, 100],
</code></pre>
<p>搜索字样：tool_tip_label_control</p>
<p>搜索字样：quick_panel_label （从上到下，第一个即可）</p>
<pre><code>  &quot;font.size&quot;: 23,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<p>搜索字样：quick_panel_path_label</p>
<pre><code>  &quot;font.size&quot;: 18,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<p>搜索字样：quick_panel_score_label</p>
<pre><code>  &quot;font.size&quot;: 18,
  &quot;font.face&quot;: &quot;Courier New&quot;,
</code></pre>
<h3 id="修改侧边栏">修改侧边栏</h3>
<p>找到 sidebar_label ， 并添加：</p>
<pre><code>  &quot;font.bold&quot;: true,
  &quot;color&quot;: [200, 125, 0, 200],
  &quot;font.size&quot;: 18,
</code></pre>
<h1 id="添加编译环境">添加编译环境</h1>
<h2 id="普通编译基本不用配ctrlb激活">普通编译（基本不用配，ctrl+b激活）</h2>
<p>Tools =&gt; build system =&gt; new build system 输入如下内容 =&gt; 保存文件到目录</p>
<pre><code>{
    &quot;cmd&quot;: [&quot;python&quot;, &quot;-u&quot;, &quot;$file&quot;],
    &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,
}
</code></pre>
<p>上面cmd内第一个参数写python.exe路径也可以<br>
😊然后就可一选择并使用了： Tools =&gt; build system =&gt; python (ctrl+b)</p>
<h2 id="删除编译的打印错误路径日志">删除编译的打印错误路径日志</h2>
<p>上面已经安装过了，这里就不再安装了，直接面板输入 prvo =&gt; 输入default =&gt; 输入 exec.py<br>
搜索字样：if &quot;PATH&quot; in merged_env:<br>
😎注释如下信息：</p>
<pre><code># if shell_cmd:
#     self.debug_text += &quot;[shell_cmd: &quot; + shell_cmd + &quot;]\n&quot;
# else:
#     self.debug_text += &quot;[cmd: &quot; + str(cmd) + &quot;]\n&quot;
# self.debug_text += &quot;[dir: &quot; + str(os.getcwd()) + &quot;]\n&quot;
# if &quot;PATH&quot; in merged_env:
#     self.debug_text += &quot;[path: &quot; + str(merged_env[&quot;PATH&quot;]) + &quot;]&quot;
# else:
#     self.debug_text += &quot;[path: &quot; + str(os.environ[&quot;PATH&quot;]) + &quot;]&quot;
</code></pre>
<h1 id="keys">Keys</h1>
<p>preference =&gt; key bindings</p>
<h2 id="显示隐藏-工具菜单">显示隐藏 工具菜单</h2>
<pre><code>{&quot;keys&quot;: [&quot;ctrl+m&quot;], &quot;command&quot;: &quot;toggle_menu&quot;},
</code></pre>
<h2 id="取消编译">取消编译</h2>
<pre><code>{ &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;cancel_build&quot; }
</code></pre>
<h2 id="显示隐藏侧边栏">显示/隐藏侧边栏</h2>
<pre><code>{ &quot;keys&quot;: [&quot;ctrl+k&quot;], &quot;command&quot;: &quot;toggle_side_bar&quot; },
</code></pre>
<h2 id="代码块折叠展开默认的即可">代码块折叠/展开(默认的即可)</h2>
<pre><code>默认为  ctrl + shift + [  ]
</code></pre>
<h2 id="各种搜索快捷键">各种搜索快捷键</h2>
<p>😄代码搜索（最好用）：</p>
<pre><code>ctrl + p

有几种用法：
1. 直接输入内容，表示查找文件名
2. @函数名，表示查找函数名。eg  @write_file
3. :数字n ，表示跳转到第n行。 eg  :65
4. #变量名， 表示查找变量名。eg   #name
</code></pre>
<p>文本搜索</p>
<pre><code>ctrl + f
</code></pre>
<p>多文件搜索<br>
😶注意：也许pycharm不需要关闭繁体也能用，但是sublime必须关繁体切换才能用此key</p>
<pre><code>ctrl + shift + f
</code></pre>
<p>替换(默认的即可)</p>
<pre><code>ctrl + H
</code></pre>
<h2 id="选择括号内的内容默认即可">选择括号内的内容(默认即可)</h2>
<pre><code>ctrl + shift + m
</code></pre>
<h2 id="切换标签页">切换标签页</h2>
<pre><code>ctrl + page up / page down
或者 alt + 1  alt + 2   .............
后者 ctrl + tab
</code></pre>
<h2 id="创建新标签页新文件">创建新标签页/新文件</h2>
<pre><code>ctrl + n
</code></pre>
<h2 id="创建新sublime窗口">创建新sublime窗口</h2>
<pre><code>ctrl + shift + n
</code></pre>
<h2 id="窗口并排">窗口并排</h2>
<pre><code>alt + shift + 1     // 1排
alt + shift + 2     // 2排
alt + shift + 3     // 3排
alt + shift + 4     // 4排
</code></pre>
<h1 id="plugins">Plugins</h1>
<h2 id="语言插件不建议使用">语言插件（不建议使用）</h2>
<pre><code>localizeMenu
</code></pre>
<h2 id="路径提示">路径提示</h2>
<pre><code>autofilename		# 文件路径提示
</code></pre>
<h2 id="侧边栏选项增强">侧边栏选项增强</h2>
<pre><code>sidebarenhancements
</code></pre>
<p>快捷键配置：</p>
<pre><code>{ &quot;keys&quot;: [&quot;delete&quot;], &quot;command&quot;: &quot;side_bar_delete&quot; },
{ &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_rename&quot; },
{ &quot;keys&quot;: [&quot;ctrl+shift+x&quot;], &quot;command&quot;: &quot;side_bar_move&quot; },

// { &quot;keys&quot;: [&quot;ctrl+shift+c&quot;], &quot;command&quot;: &quot;side_bar_copy&quot; },
// { &quot;keys&quot;: [&quot;ctrl+shift+v&quot;], &quot;command&quot;: &quot;side_bar_paste&quot; },
</code></pre>
<h2 id=""></h2>
<pre><code>alignment
</code></pre>
<h2 id="anaconda">Anaconda</h2>
<p>package settings -&gt; anaconda -&gt; settings user<br>
😊加入下面的配置，可以起到语法格式化的作用（保存ctrl+s后自动格式化）</p>
<pre><code>{
    &quot;python_interpreter&quot;: &quot;D:/python391/python.exe&quot;,
    &quot;auto_formatting&quot;: true,
    &quot;autoformat_ignore&quot;:
        [
            &quot;E309&quot;,
            &quot;E501&quot;
        ],
    &quot;pep8_ignore&quot;:
        [
            &quot;E309&quot;,
            &quot;E501&quot;
        ],
    &quot;anaconda_linting&quot;:false,
        
    &quot;anaconda_linter_underlines&quot;: false,
    &quot;anaconda_linter_mark_style&quot;: &quot;None&quot;,
    &quot;display_signatures&quot;: false,   // 这是函数内部帮助文档提示，我不需要，设false
    // &quot;disable_anaconda_completion&quot;: true  //不能打开它, 打开它anaconda就没有意义了
    // &quot;swallow_startup_errors&quot;: true    // 若anaconda报错，则打开它，否则不用
}
</code></pre>
<p>代码跳转快捷键为默认 ctrl + alt + g</p>
<h2 id="sublimerepl">sublimeREPL</h2>
<pre><code>直接搜 sublimeREPL 安装

tools =&gt; sublimeREPL
</code></pre>
<h2 id="terminal插件">Terminal插件:</h2>
<p>😶打开当前文件所在Terminal<br>
preference =&gt; package settings =&gt; Terminal =&gt; Setting Users<br>
我的是Windows Terminal</p>
<pre><code>{

&quot;keys&quot;: [&quot;ctrl+shift+t&quot;],
&quot;terminal&quot;: &quot;C:/Users/lin/AppData/Local/Microsoft/WindowsApps/wt.exe&quot;,
&quot;parameters&quot;: [&quot;-d&quot;, &quot;.&quot;]
}
</code></pre>
<p><a href="https://github.com/wbond/sublime_terminal">=&gt; terminal官档，也有其他OS版配置</a></p>
<h1 id="vs-code">VS code</h1>
<h2 id="倒叙说明">倒叙说明</h2>
<p>VSC频繁宕掉，已卸载😀，还是Pycharm+Sulime+Jupyter+Miniconda了</p>
<h2 id="中文语言">中文语言</h2>
<pre><code>ctrl + shift + p
输入 language display， 点击，左侧选择安装中文语言
</code></pre>
<h2 id="配置默认终端">配置默认终端</h2>
<p>修改控制台字体(不然PS7 和 WSL 的ZSH图标显示不出来)</p>
<pre><code>右下角 ⚙ 配置
     =&gt; 搜索 terminal font
          =&gt; 将 terminal font family 写入=&gt;  Hack NF
</code></pre>
<p>修改默认Terminal</p>
<pre><code>😀 ctrl +~    调出控制台
下拉菜单选择， 配置默认终端， 选择PS7即可。
然后关闭 终端
重新 按  ctrl +~  ， 再次打开终端即为 PS7
</code></pre>
<h2 id="快捷键">快捷键</h2>
<p>调出控制台</p>
<pre><code>ctrl + ~
</code></pre>
<p>打开命令面板（和 sublime差不多）</p>
<pre><code>ctrl + shift + p
</code></pre>
<h2 id="插件">插件</h2>
<p>python:</p>
<pre><code>vs右侧有，会推荐给你语言插件，直接点python即可
</code></pre>
<p>pylint（语法高亮提示）:</p>
<pre><code>新建py文件运行，他会自动提示你安装pylint
</code></pre>
<p>Python snippets（不建议用）</p>
<pre><code>代码块补全
</code></pre>
<p>sublime keymap and settings importer</p>
<pre><code>sublime式
</code></pre>
<p>remote WSL</p>
<pre><code>可以打开WSL环境的Vscode
</code></pre>
<p>remote SSH</p>
<pre><code>ssh
</code></pre>
<p>remote containers</p>
<pre><code>docker
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ IDE => My Pycharm]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-9/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-9/">
        </link>
        <updated>2021-03-03T07:17:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="版本">版本</h1>
<p>2021.1 community EAP</p>
<h1 id="主题">主题</h1>
<p>主题：</p>
<pre><code>默认黑色模式主题即可（三方插件不稳定，容易宕）
</code></pre>
<p>加背景图片： （插件  backgroundimage）</p>
<pre><code>安装插件之后
    直接设置中搜   image  (或者搜 appearance)
    进去 下方就多了一个 Background image的选项👍
加载背景之后，注意了
👍👍  ctrl+shift+p, 搜 image ，然后，把所有选项关闭（或者直接禁用此插件即可）
</code></pre>
<p>图标插件</p>
<pre><code>Atom Material Icons
</code></pre>
<h1 id="恢复默认配置">恢复默认配置</h1>
<pre><code>File -&gt; 
    Manage IDE Settings -&gt; 
        Restore Default Settings
</code></pre>
<h1 id="修改终端">修改终端</h1>
<p>因表情符号实在不能支持，所以把把PS5换个主题（PS7继续保留）</p>
<pre><code>locate negligible.omp.json
然后在 ps5配置文件，把这个  &quot;negligible.omp.json&quot; 文件位置替换即可
这是个 不错的主题，比之前的好，还支持 虚拟环境😀
</code></pre>
<p>换终端PS5:</p>
<pre><code>locate powershell.exe
# 然后在 pycharm中搜 terminal  ， 把此路径粘进去, 后面加个  /nologo
</code></pre>
<h1 id="字体">字体</h1>
<pre><code>界面：Droid Serif
代码：Courier New
终端：Hack Nerd Font
</code></pre>
<h1 id="修改运行内存">修改运行内存</h1>
<pre><code>locate pycharm64.exe.vmoptions
sublime &quot;C:\Program Files\JetBrains\PyCharm Community Edition 211.6085.15\bin\pycharm64.exe.vmoptions&quot;

改为： -Xmx3072m
</code></pre>
<h1 id="陈列">陈列</h1>
<p>左下角：正方形图标：类似Sublime, 集 Pannel于一体</p>
<pre><code>悬停可以看到各种 功能 view 
例如：
    alt + 1  显示/隐藏  项目功能侧边栏
</code></pre>
<p>右下角：解释器信息：类似Sublime, 在此可以切换/添加解释器（真方便）</p>
<h1 id="快捷键">快捷键</h1>
<h2 id="sublime快捷键">Sublime快捷键</h2>
<pre><code>选择 Sublime Text （ST若有快捷键，优先选择ST, 若ST无此快捷键，则仍可使用pycharm）
</code></pre>
<p>选择ST后，你可以使用</p>
<pre><code>ctrl + shift + p  
ctrl + p
ctrl + H
ctrl + n
ctrl + o
并且 仍可以使用 pycharm的:
    shift + f6
.......................
</code></pre>
<h2 id="pycharm快捷键">Pycharm快捷键</h2>
<p>上面说了，虽然使用了Sublime的快捷键，但是一些sublime没有的，pycharm的依然能用</p>
<h3 id="选中文本但把tab刨除">选中文本（但把tab刨除）</h3>
<p>使用情况1：选中非空白</p>
<pre><code>1. 按住滑轮，拖动选中全部 （什么范围都行）
2. 如果想一个空白都不要，那就继续 按  end, 再接  shift + home从尾选到头
</code></pre>
<p>使用情况2：选中空白tab</p>
<pre><code>1. 按住滑轮，拖动选中全部（什么范围都行）
2. 按 home , 在接  shift + home
</code></pre>
<p>使用情况3：选中空白tab+文本（tab格式保留）</p>
<pre><code>1. 按住滑轮，拖动选中全部（这里对范围就有一些要求了，你想要什么tab格式的，就从哪里拖）
2. 垂直拖+水平拖，即可
</code></pre>
<h3 id="多功能小面板">多功能小面板</h3>
<pre><code>ctrl + `
</code></pre>
<h3 id="代码格式化">代码格式化</h3>
<pre><code>ctrl + shift + L
</code></pre>
<h3 id="插入片段通常类插入方法">插入片段(通常类插入方法)</h3>
<pre><code>alt + insert
</code></pre>
<h3 id="跳转到n行">跳转到n行</h3>
<pre><code>ctrl + G
</code></pre>
<h3 id="列出所当前工程所有文件需要一直按住然后用鼠标去点击选择">列出所当前工程所有文件，（需要一直按住，然后用鼠标去点击选择）</h3>
<pre><code>ctrl + tab
</code></pre>
<h2 id="改键ctrlshiftp输入keymap-configure-keymap">改键（ctrl+shift+p，输入keymap-&gt;configure keymap）</h2>
<h3 id="字体大小滑轮">字体大小（滑轮）</h3>
<p>输入 font size</p>
<pre><code>(add mouse shortcut)
increase font size
decrease font size
</code></pre>
<p>输入 run context configuration</p>
<pre><code>添加一个 ctrl + B  
</code></pre>
<h3 id="跳入源码">跳入源码</h3>
<p>keymap输入：declaration or usages</p>
<pre><code>add mouse :  ctrl + 左键
</code></pre>
<h3 id="源码前进">源码前进</h3>
<p>搜navigate： （修改其下 forward）</p>
<pre><code>ctrl + alt + -&gt;
</code></pre>
<h3 id="源码返回">源码返回</h3>
<p>搜navigate： （修改其下 back）</p>
<pre><code>ctrl + alt + &lt;-
</code></pre>
<h3 id="缩进">缩进</h3>
<p>搜 indent selection</p>
<pre><code>shift + tab
</code></pre>
<h2 id="debug">Debug</h2>
<p>说一下原按钮的快捷键及作用（从左到右，无图，自己对照）：</p>
<p>第一个：show execution point（alt + F10）</p>
<pre><code>作用：只要你开了Dubug无论光标处于代码何处，都会跳到当前将要执行的断点处。
</code></pre>
<p>第二个：step over（F8）</p>
<pre><code>作用：单步执行时，不会进入官方库
 😀但是如果，点了 第三个 （step into）进去了， 那么 step over，会在里面继续单步执行的
</code></pre>
<p>第三个：step into（F7）（看源码用的）</p>
<pre><code>作用：单步执行，会进入自定义函数（但不会进入官方标准函数）
     会进入任何库的函数（通过模块，无论是标准模块还是第三方模块，都会进入）
</code></pre>
<p>第四个：step into my code（alt + shift + F7）</p>
<pre><code>作用：加入你点了第三个 step into，不慎进入了多层源码。
😀这时有两种方法，可以让你退出来。
1.  进去了多少层，你就需要按多少次 step out （也就是第六个按钮）
2.  或者你可以一步到位， 直接按 此按钮（step into my code） 直接跳出来😀
</code></pre>
<p>第五个：force step into（alt + shift + F7）</p>
<p>暂未用<br>
第六个：step out（F8）</p>
<pre><code>跳出子函数（如果执行了一部分，那就跳出余下的部分）（并执行完毕）
如果函数是嵌套的，那么就一层一层跳出来，跳出源码上面说到了可用step into my code😀)
</code></pre>
<p>第七个：run to cursor（alt+F9）</p>
<pre><code>此cursor并不是光标，而是断点。
意思就是， 执行到断点处停止
（如果是循环，那就执行一轮，到断点处停止，无论你中间有多少循环😀😀😀）
（当时如果是外层的大循环，那就没办法了。。）
-------------------------------
😀不过可在最外面和外循环同级的下面的代码打个断点，并将内循环断点删掉，然后 step out即可
</code></pre>
<h1 id="功能">功能</h1>
<h2 id="修改代码区样式">修改代码区样式</h2>
<pre><code>ctrl + `   
或 ctrl+shift+p
或 ctrl +shift + s

输入 color scheme
=&gt; 选择 Monokai 😉
</code></pre>
<h2 id="类型注释提示">类型注释+提示</h2>
<pre><code>def f(name: str):
    name.只要你写了:str这个注释， 这里就会弹出字符串对应的函数高亮提示
</code></pre>
<h2 id="函数注释片段自动生成">函数注释片段自动生成</h2>
<p>搜docstring format (tools下的)：</p>
<pre><code>将其值，选为 Epytext
</code></pre>
<p>然后函数内的头部输入 &quot;&quot;&quot;回车， 或者'''回车都可， 成功生成</p>
<h1 id="插件">插件</h1>
<h2 id="快捷键展示">快捷键展示</h2>
<pre><code>Presentation Assistant
</code></pre>
<h1 id="自定义代码段">自定义代码段</h1>
<p>搜 live template ,<br>
右上角加号 ：add  template group 名为 py<br>
继续右上角加号： add live template</p>
<p>super(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">class</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span></span></span></span>, self).<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>e</mi><mi>t</mi><mi>h</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">method</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span>)</p>
<p>@property<br>
def <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">NAME</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>(self):<br>
return <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>N</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">END</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span></p>
<p>@<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">NAME</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>.setter<br>
def <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">NAME</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>(self, value):<br>
pass</p>
<p>@<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">NAME</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>.deleter<br>
def <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>A</mi><mi>M</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">NAME</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>(self):<br>
pass</p>
<p>for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>D</mi><mi>E</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">INDEX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>A</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">VAR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> in enumerate(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>T</mi><mi>E</mi><mi>R</mi><mi>A</mi><mi>B</mi><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">ITERABLE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>):<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>N</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">END</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span></p>
<p>[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>A</mi><msub><mi>R</mi><mi>E</mi></msub><mi>X</mi><mi>P</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">VAR_EXPR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>A</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">VAR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>T</mi><mi>E</mi><mi>R</mi><mi>A</mi><mi>B</mi><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">ITERABLE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>A</mi><msub><mi>R</mi><mi>E</mi></msub><mi>X</mi><mi>P</mi><msub><mi>R</mi><mi>I</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">VAR_EXPR_IF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>]<br>
{<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>E</mi><msub><mi>Y</mi><mi>E</mi></msub><mi>X</mi><mi>P</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">KEY_EXPR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>A</mi><msub><mi>L</mi><mi>E</mi></msub><mi>X</mi><mi>P</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">VAL_EXPR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>A</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">VAR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>T</mi><mi>E</mi><mi>R</mi><mi>A</mi><mi>B</mi><mi>L</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">ITERABLE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> if <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>A</mi><msub><mi>R</mi><mi>E</mi></msub><mi>X</mi><mi>P</mi><msub><mi>R</mi><mi>I</mi></msub><mi>F</mi></mrow><annotation encoding="application/x-tex">VAR_EXPR_IF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GO => Golang持续...]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-8/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-8/">
        </link>
        <updated>2021-03-03T07:17:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="env">ENV</h1>
<h3 id="goroot-默认go安装根目录即可">GOROOT: 默认go安装根目录即可</h3>
<pre><code>D:\code\go
</code></pre>
<h3 id="gopath工程目录里面有bin-pkg-src">GOPATH：工程目录（里面有bin, pkg, src）</h3>
<pre><code>D:\code\go\work
    # 我们只需用goland 去 open src目录即可
</code></pre>
<h3 id="gobingopath里面的bin目录">GOBIN：GOPATH里面的bin目录</h3>
<p>作用： go install 生成的exe 会自动存到这里</p>
<pre><code>D:\code\go\work\bin
</code></pre>
<p>此外我们还需将此目录放入到环境变量，随时随地exe执行</p>
<h3 id="go111module">GO111MODULE</h3>
<pre><code>off ：无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。
on ：模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。
auto ：在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。
</code></pre>
<h1 id="平台go命令">平台+Go命令</h1>
<h2 id="查看go的环境变量">查看GO的环境变量</h2>
<pre><code>go env | grep GOOS
go env | grep GOARCH
</code></pre>
<p>GOOS变量值是什么平台，编译后的文件就只能在什么平台运行</p>
<h2 id="windows">windows:</h2>
<pre><code> go build .\hello.go
.\hello.exe
</code></pre>
<p>Goland terminal修改GOOS</p>
<pre><code>cmd: set GOOS=linux
ps:    $env:GOOS=&quot;linux&quot;
# go env | grep GOOS   # 此时已变为linux

go build .\hello.go
.\hello
# 😴 执行失败，平台不兼容
</code></pre>
<h2 id="linux">linux:</h2>
<pre><code>./hello 执行成功
./hello.exe    执行成功 （纯Linux是会执行失败的，但是这是WSL）
# WSL特殊，因为WSL可以兼容执行windows exe的格式
</code></pre>
<h2 id="go-install">go install</h2>
<p>把目录下 go build 编译后的 exe文件，自动添加到 GOBIN目录下</p>
<pre><code># 需要把上面的环境变量配置好：GO111MODULE auto
go install
</code></pre>
<h1 id="赋值">赋值</h1>
<pre><code>:=       (python3.8也出了，不过，其用途是 条件赋值一体化)
</code></pre>
<p>特殊：空赋值（定义后可不使用，也不能使用）： _</p>
<pre><code>a := 1    // a必须在下文使用
_,b := 1,2  // 必须在下文使用
// _,_ := 1,2  // 这种写法是错误的
_,_ = 1,2   // 当有所有变量都是空变量的时候， 用 = 即可，而不是用:=
</code></pre>
<h1 id="真假">真假</h1>
<p>只有 true/false<br>
不能使用 0 &quot;&quot; 之类的数据来代替真假（py可以， if 1:pass）</p>
<h1 id="i">i++</h1>
<p>go: 只有 i++ 和 i+= ,  且只能单独放一行 (i-- 和 i-= 也是可以的)<br>
py: 只有 i+=</p>
<h1 id="交换变量的四种方式">交换变量的四种方式</h1>
<p>下面代码，除了数据声明与定义，其他Py 和 Go 的语法都是一摸一样的（主要强调 异或方式）<br>
a := 1<br>
b := 3</p>
<h3 id="方式0">方式0</h3>
<pre><code>c := 0
c = a
a = b
b = c
</code></pre>
<h3 id="方式1">方式1</h3>
<pre><code>a,b = b,a
</code></pre>
<h3 id="方式2">方式2</h3>
<pre><code>a = a + b
b = a - b
a = a - b
</code></pre>
<h3 id="方式3-注必须是整形-py也一样">方式3 （注：必须是整形， Py也一样）</h3>
<pre><code>a = a ^ b
b = a ^ b
a = a ^ b

fmt.Println(a)
fmt.Println(b)
</code></pre>
<h1 id="string">string</h1>
<p>原生字符串输入：</p>
<pre><code>python &quot;&quot;&quot; &quot;&quot;&quot;
golang ` `          反引号
</code></pre>
<p>python和golang都是内部不可变，外部可变（可以整体替换赋值）<br>
都有 len()</p>
<h1 id="数组">数组</h1>
<h2 id="定长创建">定长创建</h2>
<p>方式1</p>
<pre><code>arr1 := [3]int{1,2,3}
</code></pre>
<p>方式2</p>
<pre><code>var arr2 [3]int
arr2 = [3]int{1,2,3}
fmt.Println(arr1)
fmt.Println(arr2)
</code></pre>
<h2 id="非定长创建">非定长创建</h2>
<pre><code>arr1 := []int{1,2,3}
</code></pre>
<p>append:</p>
<pre><code>arr1 = append(arr1, 4)
</code></pre>
<p>len:</p>
<pre><code>len(arr1)
</code></pre>
<p>😏cap:</p>
<pre><code>arr1 := []int{1,2,3}
fmt.Println(len(arr1),cap(arr1))      // 3,3
arr1 = append(arr1, 4,5)	  // 5,6  
fmt.Println(len(arr1),cap(arr1))
</code></pre>
<p>len()的变化是没什么好说的<br>
cap() 首先 arr1的只有3个元素，容量就分了3个（满了）<br>
既然满了，那就append一个元素，开一个空间？这太费劲了。<br>
于是 go 会在你每次元素容量溢出的时候，为你😊2倍扩容。</p>
<p>😑注意0，不足1024，2倍扩容。 超过1024，1.25倍扩容。<br>
😑注意1，这个二倍是在现有的容量进行2倍扩容。 eg:</p>
<pre><code>3 * 2 = 6
6 * 2 = 12
...
</code></pre>
<p>😊特别注意<br>
如果是用 for 循环的方式append （）</p>
<pre><code>那么你给多少长度，他就会给你扩充至多少。
😊虽然最后一次遍历输出看起来 len 和 cap 趋近相等
😊但是每一次循环的过程，还是采用 二倍扩容原则！！！
</code></pre>
<p>eg:</p>
<pre><code>arr1 := []int{1,2,3}
fmt.Println(len(arr1),cap(arr1))      // 3,3
for i := 0; i &lt; 92; i++ {
	arr1 = append(arr1, i)
}
fmt.Println(len(arr1),cap(arr1))      // 95, 96
arr1 = append(arr1, 1,2,3,4,5) // 我们的容量只有96，所以越界了，2倍
fmt.Println(len(arr1),cap(arr1))      // 96, 192
</code></pre>
<h2 id="遍历">遍历</h2>
<p>方式1：</p>
<pre><code>for i, v := range arr2 {    // 和python一样 v只是copy的值，并不能用v改变数组
	fmt.Println(i,v)           // index,  value
}
// fmt.Println(i,v)    // 报错 , 因为上面的 i, v 都是临时变量， python则体外可用
</code></pre>
<p>😎Note: Go的 i,和v都是临时面两<br>
方式2：</p>
<pre><code>for i := 0; i &lt; len(arr2); i++ {
	fmt.Println(i,arr2[i])
}
</code></pre>
<h1 id="切片">切片</h1>
<h2 id="认知">认知</h2>
<p>和python一样，都是左闭右开</p>
<pre><code>arr1 := []int{1,2,3,4,5,6,7}
slice1 := arr1[2:5]
fmt.Println(slice1)
</code></pre>
<h2 id="使用方式">使用方式</h2>
<pre><code>[:n]
[m:]
</code></pre>
<p>数组转切片：<br>
// 这个和python截然相反，go意味着数组转切片，完全引用（指针），py表示浅拷贝<br>
[:]</p>
<h2 id="原理">原理</h2>
<p>切片就是数组的部分引用（指针）（2者都是互相，牵一发而动全身，）<br>
😣这点和python完全相反（python 切出来就是新地址了）</p>
<h2 id="创建指定空切片长度len容量cap">创建指定空切片,长度len+容量cap</h2>
<p>好处：一次性分配，成本开销低。</p>
<pre><code>str2 := make([]string, 0, 20)      // 如果不指定cap, 则默认与len一致
fmt.Println(len(str2), cap(str2))  // len=0, cap=20
</code></pre>
<h2 id="浅拷贝">浅拷贝</h2>
<p>copy(新，旧) ， 二者必须都是切片类型 （数组转切片上面说了 [:]）</p>
<pre><code>arr1 := [5]int{1,2,3,4,5}
slice1 := make([]int, len(arr1))
copy(slice1, arr1[:])  // arr1必须转切片， arr1[:]
fmt.Println(slice1)
</code></pre>
<h1 id="if">if</h1>
<p>无小括号</p>
<h1 id="for">for</h1>
<p>无小括号</p>
<h1 id="指针">指针</h1>
<p>GC自动回收，不需要手动回收(py可 del 动态回收)</p>
<h2 id="new">new</h2>
<pre><code>name := new(string) // new出来的就地址
*name = &quot;zhangsan&quot;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 7]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-7/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-7/">
        </link>
        <updated>2021-03-03T07:17:07.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 7</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 6]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-6/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-6/">
        </link>
        <updated>2021-03-03T07:16:52.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 6</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 5]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-5/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-5/">
        </link>
        <updated>2021-03-03T07:16:35.000Z</updated>
        <content type="html"><![CDATA[<p>RS =&gt; 5</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 个性化召回]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-4/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-4/">
        </link>
        <updated>2021-03-03T07:16:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="lfmlatent-factor-model">LFM(latent factor model)</h1>
<p>升级版的SVD（奇异值分解）</p>
<h2 id="应用场景">应用场景</h2>
<ol>
<li>UI推荐列表</li>
<li>Item之间相似度列表</li>
<li>Item之间隐含Topic挖掘</li>
</ol>
<h2 id="模型参数">模型参数</h2>
<p>隐特征：10-32<br>
正则化系数：0.01-0.05<br>
Learning Rage: 0.01-0.05</p>
<h2 id="lfm缺点">LFM缺点</h2>
<p>召回计算Toplike，一个User向量，需要与每个Item向量点乘运算，耗时高，实时感知差</p>
<h2 id="item2vec">Item2vec</h2>
<ul>
<li>做成格式1： dict1 ={'user_id': [item1, item2, ..., itemN]}</li>
<li>取出每个user_id的value列表作为文件的每一行 items : dict1.values()</li>
<li>每行 itemId 以空格分隔 （文件内只保存ItemID,  不需要userId）</li>
</ul>
<p>Google Word2Vec:</p>
<pre><code>word2vec -train $train_file -output $item_vec_file -size 128 -window 5 -sample 1e-3 -negative 5 -hs 0 -binary 0 -cbow 0 -iter 50
</code></pre>
<p>输入文件的内容格式（ItemID+它自己的向量（128维也就是对应上面的-size参数））：</p>
<pre><code>ID  一维向量 二维度向量.........................................128维向量
25  0.392720 0.115408 -0.177216 0.152538 -0.185550 -0.048845 ... 128个
...
</code></pre>
<p>根据上面训练出的Item向量，互相计算Item之间的相似度（Cos即可）<br>
并取TopK最终格式为：</p>
<pre><code>25  itemID1_相似度  itemID2_相似度  itemID3_相似度  itemID4_相似度。。。
...
</code></pre>
<h1 id="基于内容召回content-based">基于内容召回（Content Based）</h1>
<h2 id="步骤">步骤</h2>
<ul>
<li>抽取
<ul>
<li>文本： Item Profile（Title，分词，主题词，关键词（TF-IDF, TextRank））</li>
<li>视频：关键帧图像的分类识别</li>
<li>音频：语音识别+文字处理</li>
</ul>
</li>
<li>抽取 user Profile (对Item的行为，给用户打标签，时间衰减)</li>
<li>实时推荐</li>
</ul>
<p>优点：简单，解释性强，用户之间独立性强（用户点什么，就推和此Item内容相关）<br>
缺点：特征抽取难，跨领域弱，可能造成大部分都推同一类。 另外需要积累一定量的用户行为</p>
<h1 id="sigmoid导数">Sigmoid导数</h1>
<p>fx = sigmoid<br>
fx' = fx( 1-f(x) )</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => 个性化]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-3/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-3/">
        </link>
        <updated>2021-03-03T07:15:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="商业用户指标">商业用户指标</h1>
<p>DAU：每日活跃用户数量<br>
用户留存：User某段时间开始使用产品，过一段时间，仍继续使用该产品</p>
<h1 id="相似度">相似度</h1>
<h2 id="杰卡德相似度">杰卡德相似度</h2>
<p>只倾向适用于用于0，1点击类数值：</p>
<pre><code>          Item A  Item B  Item C  Item D  Item E
User1       1       0       1       1       0
User2       1       0       0       1       1
User3       1       0       1       0       0
User4       0       1       0       1       1
User5       1       1       1       0       1
</code></pre>
<h2 id="向量内积点积">向量内积(点积)</h2>
<p>几种表现形式：</p>
<pre><code>A转置 B 
&lt;A,B&gt;
A·B
</code></pre>
<p>两种计算方式，做连等，求 cosθ：</p>
<pre><code>A·B = |A| · |B| · cosθ
A·B = a1*b1 + a2*b2 + ..... an*bn
</code></pre>
<h2 id="余弦相似度">余弦相似度</h2>
<pre><code>C为B在A上的投影（AC同向）
A·B  = |A| · |B| · cosθ = |A| · |C| &gt; 1 (角度越大，C值越小，内积越小，越不相似)

θ越小越好， cosθ 约大越好
</code></pre>
<p>取值范围:</p>
<pre><code>[0.1]
</code></pre>
<p>余弦相似度存在弊端：（归一化，认知）</p>
<pre><code>假如某用户user1没见过世面，看见的东西都是好的，那么就会给最高分
又有某用户user2见多识广，看见的东西都不合口味，那么不排除审美偏高，则全打低分。
</code></pre>
<p>所以这种情况需要一种力量把盲高拉低， 把盲低拉高。那就是（依靠平均值）<br>
进而衍生出了皮尔逊相关系数 👇</p>
<h2 id="皮尔逊相关系数">皮尔逊相关系数</h2>
<ul>
<li>就是把 余弦相似度，的每个子项（细致入微到最小颗粒）都 减去一个 均值。</li>
<li>再按余弦相似度正常计算即可。</li>
</ul>
<p>API：（和杰卡德相似，都是按列计算，若要求用户相似度，需转置。）</p>
<pre><code>df.T.corr() # 求所有Item之两两相似度
</code></pre>
<p>取值范围：</p>
<pre><code>[-1. 1]
</code></pre>
<h2 id=""></h2>
<h1 id="离线召回">离线召回</h1>
<p>协同、FM、DSSM</p>
<p>计算Item A 和Item B的相似度(根据列，若求User之间的相似度需要转置 df.T.values)</p>
<pre><code>from sklearn.metrics import jaccard_score
print(jaccard_score(df[&quot;Item A&quot;], df[&quot;Item B&quot;])) # (A∩B) / (A∪B) = 1/5=0.2
</code></pre>
<h2 id="用户协同过滤-usercf">用户协同过滤 UserCF</h2>
<p>A用户相似B用户有相同的Item C，   把A喜欢的其他的Item 直接推给B即可</p>
<h1 id="实时召回">实时召回</h1>
<ul>
<li>实时画像</li>
<li>实施增益计算</li>
<li>后验排序调整</li>
</ul>
<h1 id="增量更新day">增量更新/day</h1>
<p>拿新数据去，model save/model load，更新模型参数，继续model load + model save</p>
<h1 id="全量更新-防止模型局部收敛-全量更新15day">全量更新 (防止模型局部收敛， 全量更新/15day)</h1>
<p>拿着新数据重新训练模型(所有参数全部重来)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PY => Python基础冷点备忘（2017-2021）]]></title>
        <id>https://cythonlin.github.io/post/rs-greater-2/</id>
        <link href="https://cythonlin.github.io/post/rs-greater-2/">
        </link>
        <updated>2021-03-03T07:15:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="目的">目的</h1>
<p>把远古写的笔记全部删除，浓缩到此篇文章！<br>
知其然且知其所以然！<br>
冷门且高级且易忘！！！😏😏</p>
<h1 id="放一个最简单的大招">放一个最简单的大招😏</h1>
<p>知道单元素元组为什么要 ( ,) 这样设计，而非 ()？</p>
<pre><code>a = (1+2)           # 3
b = (1+2,)          # (3,)
c = (1+2) * (3+4)   # 21   👈 就是为了避开这个
d = (1+2,) + (3+4,) # (3, 7)
</code></pre>
<h1 id="可变类型与不可变类型">可变类型与不可变类型：</h1>
<pre><code>可变类型：[], {}                # 可增删改 查
不可变类型: int float str ()    # 无法增删改， 只可查
</code></pre>
<p>区别：+ 与 += ：</p>
<pre><code>+: 
    无论是可变类型 还是 不可变类型， 都是新指向的空间
+=:  
    对于可变类型：原地操作，原指向，原空间 😀建议😀
    对于不可变类型：异地操作，新指向，新空间
=+:
    正数赋值
</code></pre>
<h1 id="字典与集合">字典与集合</h1>
<p>字典如下函数与集合的关系：</p>
<pre><code>keys()
values()
items()
返回值皆支持集合操作
</code></pre>
<p>py39字典新增</p>
<pre><code>| （并集运算符）
|= （并集赋值符）

&gt;&gt;&gt; a = {1:1, 2:2}
&gt;&gt;&gt; b = {1:3, 3:4}
&gt;&gt;&gt; a | b
{1: 3, 2: 2, 3: 4}
&gt;&gt;&gt; b | a
{1: 1, 3: 4, 2: 2}

# 十个字概括： 键异扩新项，键同赋新值
# 注意1： |  后为新项/新值
# 注意2： 此运算符，是计算出的新结果，需要赋给新变量使用
</code></pre>
<p>提一嘴集合：</p>
<pre><code>赋新值运算符：（并交叉）
    a | b   
    a &amp; b
    a - b

函数不建议使用：
    略
</code></pre>
<h1 id="高阶函数">高阶函数</h1>
<p>总是记不住高阶函数的参数位置吗？ 那我觉得这个概念有必要提一嘴：👇</p>
<pre><code>函数是一等公民  了解一下！！！
</code></pre>
<h2 id="map很简单这里只说map双参的实现方案">map很简单，这里只说map双参的实现方案：</h2>
<p>方案1：偏函数，基础，略</p>
<pre><code>from functools import partial
略
</code></pre>
<p>😀方案2：starmap 多参，这才是我想说的，我相信很少人用过</p>
<pre><code>from itertools import starmap

list(
    starmap(
        lambda x, y,z: print(x + 100, y + 200,z+300),
        ((1,2,3),(4,5,6))
        # 可见虽然dict.items()，不是严格双层，但也帮我们强转
    )
)

# 101 202 303
# 104 205 306
#😀😀 不仅可以传 Sim-dict 这种 Nx2格式的， 还能传 NxN格式的（N行N列）
</code></pre>
<h2 id="zip-很简单唯一注意的就是不规则参数">zip 很简单，唯一注意的就是不规则参数</h2>
<p>只取前N为能1V1匹配到的，如果不匹配并不会报错，而是直接过滤单个的</p>
<pre><code>In [132]: list(zip((1,2),(3,4,5)))
Out[132]: [(1, 3), (2, 4)]
</code></pre>
<h1 id="字典生成式-和-集合生成式-易混区分">字典生成式 和 集合生成式 易混区分</h1>
<p>集合生成式，（x,y必须要用序列包起来）</p>
<pre><code>set1 = {(x,y) for x,y in dict(a=1,b=2).items()}
print(set1)
</code></pre>
<p>字典生成式，必须要写 : , 谨记 必须冒号，才是字典😀😀并且一定不要用括号</p>
<pre><code>dict1 = {x:y for x,y in dict(a=1,b=2).items()}
print(dict1)
</code></pre>
<h1 id="三器">三器</h1>
<h2 id="可迭代对象-生成器-迭代器三者的关系">可迭代对象、生成器、迭代器三者的关系：</h2>
<pre><code>1. 迭代器，生成器一定是可迭代对象
2. 生成器是迭代器的一种（子集）
3. 可迭代对象：必须实现 __iter__方法
4. 迭代器：必须实现 __iter__方法  和__next__方法 
5. 😀生成器：包含yield的函数 或 (生成器推导语法) 才是Generator生成器，否则都是迭代器
6. 😀生成器看着是函数，但是它底层依然是实现了 __iter__() 和 __next__() 的类
7. 可迭代对象都可被for循环 所遍历， 另外实现了 __getitem__的类 其对象也可for遍历
8. 工具包： from collections import Iterable,Iterator （PY39已被废除）
9.  新工具包：from collections.abc import Iterator,Generator,Iterable
</code></pre>
<p>验证生成器是否 是（迭代器，生成器，可迭代对象）代码：</p>
<pre><code>from collections.abc import Iterator,Generator,Iterable
def fun():
    for x in range(10):
        a = yield x
        print(a)
f = fun() 

print(isinstance(f, Iterator))      # True
print(isinstance(f, Generator))     # True
print(isinstance(f, Iterable))     # True
</code></pre>
<p>验证不具有yield 或 ()推导生成式类是否为生成器：</p>
<pre><code>class A():
    def __iter__(self):
        pass
    def __next__(self):
        pass
obj = A()
print(isinstance(obj, Iterator))      # True
print(isinstance(obj, Generator)) # False   
# 👆上面这个False可以看出， 虽然实现了 __iter__和 __next__
# 👆但是并没有 yield 或 ()推导生成式，所以它只能叫迭代器，而不是生成器
print(isinstance(obj, Iterable))     # True
</code></pre>
<h3 id="generator-推理单步迭代的3种方式">Generator 推理单步迭代的3种方式：</h3>
<p>先挑明：</p>
<ul>
<li>他们都有 next(),和__next__()  但是😲</li>
<li>迭代器没有 send() 方法</li>
<li>生成器有 send()  方法：因为send()是专门为 yield提供的</li>
</ul>
<p>代码解释：</p>
<pre><code># next(f)  和 f.__next__()   这两种很简单，略
# 😀😀😀下面send()是重点，生成器专门为yield提供的 ----------------------------
def fun():
    for x in range(10):
        a = yield x
        print(a)

f = fun()                 # 无输出
f.send(None)         #  fun内无任何输出,  注意，连None都没有，只是开关的作用

c = f.send(&quot;100&quot;)         #  执行后，输出值为 100 ， 也就是 打印a的值
print(c)                  # 这个返回值就是断点处x的值， 结果为 0， 因为这是第一次send
</code></pre>
<p>😀😀😀上述send(n)语法解释:</p>
<pre><code>如果第一个使用send(n), 那么send参数必须是None， 死语法。（next不需要传参）
    Note1: 你也可使用 next(f) 和 f.__next__() 代替 第一个f.send(None)
    Note2: 第一个 next(f) 和 f.__next__() 和 f.send(None)，  都是起到开关的作用

yield流程：
    1. f.send(None) # 长官输入指令给 fun函数，并执行到 😀yield 关键词及右侧停止。
    2. a = yield x # 相当于一个士兵等待指令，等号😀左边还未执行，程序😀右边就被封锁了
    3. f.send(100)   # 长官输入100，士兵收到后就把程序😀右边解封，并执行等号左边
    4. 于是 a 被赋值为 100
</code></pre>
<h3 id="简单小结一下">简单小结一下</h3>
<p>iter(x)    可以把序列类型类型数据变为 <strong>迭代器</strong>，注意是<strong>迭代器</strong></p>
<p>其实python里面不止有 Iterator 和 Generator<br>
也有其他类型，如：</p>
<pre><code>zip()返回值
map()返回值 等
他们都是迭代器的一种。 isinstance True
</code></pre>
<p>还有一些，叫做<strong>Iterable可迭代对象</strong></p>
<pre><code> 如常见序列， 
 (),[],{},
 {}.items(), 
 range()  等
 他们既不是迭代器，也不是生成器，它们只是可迭代对象
</code></pre>
<h2 id="装饰器不多废话代码例子与注释鲜明联想">装饰器（不多废话，代码例子与注释鲜明联想）</h2>
<p>标准装饰器：</p>
<pre><code>def f(func):
    @wraps(func)
    def f1(*args, **kwargs):
        print('上面加了-奶油')
        result = func(*args, **kwargs) # 我是面包
        print('下面加了-沙拉')
        return result
    return f1

@f  # 等价于  func = f(func)
def func():
    print(&quot;我是面包&quot;)

func()

# 输出结果 👇
# 上面加了-奶油
# 我是面包
# 下面加了-沙拉
</code></pre>
<p>带参数的装饰器：（把@单个符号看作一个部分， 把@后面所有当作整体然后返回结果 交给@）<br>
其实就是最外面又套了个函数，然后这个函数 返回结果是返回之前的整体：</p>
<pre><code>from functools import wraps
def 包装纸(纸质):      # 带参数的装饰器
    print(f&quot;在外面再包一层{纸质}&quot;)
    def f(func):
        @wraps(func)
        def f1(*args, **kwargs):
            print('上面加了-奶油')
            result = func(*args, **kwargs) # 我是面包
            print('下面加了-沙拉')
            return result
        return f1

    return f

@包装纸(&quot;锡纸&quot;)  # 等价于  func = f(func)
def func():
    print(&quot;我是面包&quot;)

func()

# 输出结果 👇
# 在外面再包一层锡纸
# 上面加了-奶油
# 我是面包
# 下面加了-沙拉
</code></pre>
<p>用装饰器装饰类：</p>
<pre><code>和上面几乎一模一样， 就是装饰的是类
@f      # 等价于  A = f(A) 😎看这里，就是这里变了，传递的是类，仅此而已
class A():
    pass
</code></pre>
<p>类装饰器（上面说的都是用普通函数当作装饰器，其实类也可以作为装饰器）😎</p>
<pre><code># 其实这更简单... 

class A:
    def __init__(self,  func):
        self.func = func

    def  __call__(self, *args, **kwargs):
        self.func(*args, **kwargs)

@A      # 等价于 test = A(test)
def test():
    pass

test()
</code></pre>
<p>跟着我的思路走😎：</p>
<pre><code>1. @A 等价于 test = A(test)
2. 先执行 = 右面的，即 A(test)，这是类的实例化啊： 即第一步调用 __init__()，
3. __init__()会自动返回实例（底层是 __new__） 因为自动返回，所以无需return😎
4. 再执行等号左面的，即  test = 实例对象
5. 然后开始执行test()，即 实例对象(),  看到这里，自然而然就想到自动调 __call__()
</code></pre>
<h1 id="继承广度c3-mro">继承（广度，C3, MRO）</h1>
<p>python3中super() 等价于 super(类, self)。 所以用哪个都无所谓，一模一样。</p>
<pre><code>class A:
    def say(self, name):
        print(f'Im {name}')

class B(A):
    def say(self, name):
        # 下面两种用法一模一样
        super().say(name)                 # PY3新式
        # super(B, self).say(name)        # PY2遗留
</code></pre>
<p>👇super(D, self) 的定义说明：</p>
<pre><code>def super(cls, instance):
    mro_list = instance.__class_.mro()
    # 此类对应的下一个MRO类的 index，加1代表除了自己
    next_mro_index = mro_list.index(cls) + 1
    # 找到此索引对应的的类名并返回
    return mro_list( next_mro_index )
</code></pre>
<p>写了一大堆废话解释，全删了，直接记住下面的例子。<br>
三个要点：</p>
<ol>
<li>Mro是广度，</li>
<li>遇super则跳（当yield看）。钻牛角尖毫无意义！！！！😑</li>
<li>1和2结合起来，先广度跳（B1跳B2， 然后跳Base， 再原路返回，完美）</li>
<li>秘诀：<br>
（😑 跳之前，从左到右，从下到上画 倒Z）（横画完，则向左上方画捺，再画横，循环...）<br>
（😑 跳之后，原路返回）</li>
</ol>
<p>示例：</p>
<pre><code>class Base:
    def __init__(self, ):
        print(&quot;Base&quot;)
        
class B1(Base):
    def __init__(self, ):
        print(&quot;B1&quot;)
        super(B1, self).__init__()
        print(&quot;sorry 1&quot;)
class B2(Base):
    def __init__(self, ):
        print(&quot;B2&quot;)
        super(B2, self).__init__()
        print(&quot;sorry 2&quot;)
        
class B12(B1,B2):
    def __init__(self, ):
        super(B12, self).__init__()
b12 = B12()
</code></pre>
<p>打印结果👇：</p>
<pre><code>B1
B2
Base
sorry 2
sorry 1
</code></pre>
<h1 id="上下文管理器">上下文管理器</h1>
<h2 id="实现方式1协议__enter__协议__exit__">实现方式1（协议__enter__+协议__exit__）</h2>
<pre><code>class A:
    def __init__(self, filename, mode):
        self.f1 = open(filename, mode)
        print(&quot;人呢&quot;)
    def __enter__(self):
        print(&quot;打开了新文件&quot;)
        return self.f1

    def __exit__(self, *args, **kwargs):
        print(&quot;关闭了新文件&quot;)
        self.f1.close()

with A(&quot;1.txt&quot;, &quot;rb+&quot;) as f:
    print(&quot;读取了数据&quot;)
    print(f.read().decode(&quot;utf-8&quot;))

# 人呢
# 打开了新文件
# 读取了数据
# h哈哈哈哈哈哈哈哈哈 （这是文件read读出的内容）
# 关闭了新文件
</code></pre>
<ol>
<li>enter中return 的值，  就是 as 后面的值。</li>
<li>with后的 类必须实例化必须实例化 ，不然会报错</li>
<li>👍执行顺序是 init-&gt;enter-&gt;包围体-&gt;exit</li>
</ol>
<h2 id="实现方式2contextmanager底层也是第一种">实现方式2（@contextmanager）底层也是第一种</h2>
<pre><code>from contextlib import contextmanager as context
@context
def f():
    print(&quot;yield之前的 f()调用&quot;)
    yield &quot;执行内容&quot;
    print(f&quot;yield之后&quot;, )
with f() as a:
    print(a)
</code></pre>
<h1 id="属性描述符">属性描述符</h1>
<h2 id="方式1">方式1</h2>
<pre><code>class User:
    def __init__(self, name):
        self.__name = name
        
    def get_name(self):
        return self.__name
    def set_name(self, name):
        self.__name = name

    name = property(fget=get_name, fset=set_name, fdel=None)

u = User(&quot;Tom&quot;)
print(u.name)       # Tom
u.name = 'Bob'
print(u.name)       # Bob
</code></pre>
<h2 id="方式2">方式2</h2>
<pre><code>class User:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name
    @name.setter
    def name(self, name):
        self.__name=name
u2 = User(&quot;Jack&quot;)
print(u2.name)          # Jack
u2.name  = &quot;Mike&quot;
print(u2.name)          # Mike
</code></pre>
<h1 id="类魔法函数">类魔法函数</h1>
<h2 id="__new__-实例的生产器">__new__： 实例的生产器</h2>
<pre><code>class A:
'''
    作用： 这句话是官方源码对 __new__作用的注释：&quot;&quot;&quot; Create and return a new object.&quot;&quot;&quot;
    原理： 在实例化后，自动调用__init__, 其实在这之前还调用了__new__ ，可做拦截。
                __new__的返回值， 就是实例化对象后的对象，返回什么对象就是什么。
                并且返回值就是 __init__(self) 这里面的 self
    使用： 若重写 __new__,  需要调用父类的 __new__() 。把super()结果返回就是正常使用的self
                return super(A, cls).__new__(cls)
    扩展： 可用拦截这个特性，在实例传递给 __init__之前，对 instance做限制（单例）
'''
# 单例 例子如下

    instance = None     # 类属性， 因为 __new__中本身就是cls类， 所以必须用cls调用
    def __new__(cls, *args, **kwargs):
        if not cls.instance:
            cls.instance = super().__new__(cls) # 若无继承，则用object的new
        return cls.instance

    def __init__(self, value):
        print(value)

# 实例化先把初始值传到了 __new__ (1,)
# 然后才把初始值传到了 __init__ 1
# 实例化先把初始值传到了 __new__ (2,)
# 然后才把初始值传到了 __init__ 2
# True
</code></pre>
<p>👍最后强调一下，调用基类的new时，注意传的参数， 只传 cls，不能多传。<br>
👍我们自己定义的new, args和kwargs接收了实例化传的初始值， 并且还会把这个值无损传递给 init。<br>
👍至于如何无损传递,不要钻牛角尖，也不要去new里面修改传递的参数，没意义，直接去 init操作值即可</p>
<h2 id="__setattr__-和__getattr__-和__delattr__">__setattr__() 和__getattr__() 和__delattr__()</h2>
<pre><code>&quot;&quot;&quot;
    __setattr__()：=号 属性赋值 会自动调用此方法 
    __getattr__()：.号 属性取值 会自动调用此方法    # 注：找不到属性才会调用此方法
    __delattr__()：del 属性删除 会自动调用此方法
&quot;&quot;&quot;
</code></pre>
<h2 id="__getattribute__">__getattribute__()</h2>
<pre><code>&quot;&quot;&quot;
    和 __getattr__() 一样，只不过 __getattribute__最先调用，并拦截了 __getattr__()
&quot;&quot;&quot;
</code></pre>
<h2 id="__getitem__">__getitem__()</h2>
<pre><code>&quot;&quot;&quot;
    对对象进行 切片、索引、遍历 等 会自动调用此方法
&quot;&quot;&quot;
</code></pre>
<h2 id="__init_subclass__">__init_subclass__（）</h2>
<pre><code>&quot;&quot;&quot;
    被继承的类 会自动调用__init_subclass__ 
&quot;&quot;&quot;
</code></pre>
<h2 id="__contains__">__contains__()</h2>
<pre><code>xx in xx
</code></pre>
<h2 id="dira-和-dira-和-a__dict__-和-a__dict__-的区别">dir(a) 和 dir(A) 和 a.__dict__ 和 A.__dict__ 的区别</h2>
<ul>
<li>dir():
<ul>
<li>a：世间万物，全部都有（注意，你没听错，是全部😏）</li>
<li>A：只比 a 少了一个 实例属性。</li>
</ul>
</li>
<li>__dict__:
<ul>
<li>a: 只列出（自己的实例属性 + 继承的实例属性）</li>
<li>A: 只列出（自己的类属性+类方法+静态方法+实例方法） （注意😏没有继承，没有静态属性）</li>
</ul>
</li>
</ul>
<h2 id="一些其他属性方法">一些其他属性/方法</h2>
<p>查看mro</p>
<pre><code>A.mro()
</code></pre>
<p>查看MRO列表的下一个基类。</p>
<pre><code>A.__base__
</code></pre>
<p>查看上一代的基类（直接继承关系的都算，间接的不算）</p>
<pre><code>A.__bases__
</code></pre>
<p>查看对象的实例对应的原型类</p>
<pre><code>a1.__class__  # 查看a1的类为 A

当然类也可以, eg：  D.__class__   结果是👍 &lt;class 'type'&gt;
</code></pre>
<p>👍type站在了食物链的顶端（和type() 查看类型是一个type）<br>
👍毕竟python万物皆对象, 如果你觉得这句话不够严谨，你可以</p>
<pre><code>print(type.__class__)
print(type(type))
</code></pre>
<p>结果都是， &lt;class 'type'&gt; 。 可以看作 type实现了😏😏&quot;小自举&quot;</p>
<h1 id="浅拷贝深拷贝皮肉举例">浅拷贝+深拷贝（皮+肉举例）</h1>
<p>谨记（copy不可变类型无意义， copy可变类型才有意义）：</p>
<pre><code>无论深copy/浅copy 都无法 copy/deepcopy😏不可变类型的变量
即使你copy/deepcopy后，你id() 比较后，发现地址一致
</code></pre>
<p>用法（通常copy可变类型序列）：</p>
<pre><code>from copy import copy
c1 = copy(&lt;序列&gt;)
from copy import deepcopy
d1 = deepcopy(&lt;序列&gt;)
</code></pre>
<p>深/浅copy区别：</p>
<pre><code>浅拷贝：不同的皮肤 用 同一块肉  =&gt; 😏[ ]一层序列叫做皮
深拷贝：不同的皮肤 用 不同的肉  =&gt; 😏[ [] ] N层序列才叫肉

所以也就意味着：
    一层序列（深/浅）无区别。
    N 层序列（深/浅）才有区别：
        浅：只能copy外层，内层公用地址。（别改内层数据，你改了，我也跟着变了。。）
        深：全身copy个遍，全部新开地址。（你改你内外层的数据和我无关）
</code></pre>
<h1 id="lambda">Lambda</h1>
<p>lambda内执行多个函数:</p>
<pre><code>lambda: ([f1(), f2(), f3()]) 
</code></pre>
<p>lambda匿名 自执行函数（和JS很像）（lambda定义体必须用小括号括起来）</p>
<pre><code>(lambda x:print(x))(1)
</code></pre>
<h1 id="解构赋值">解构赋值</h1>
<pre><code>a, *_ = range(10)
*_, a = range(10)
a,*_, b = range(10)
</code></pre>
<h1 id="反射">反射</h1>
<h2 id="模块反射两种方式-import_module-和-__import__">模块反射两种方式 （import_module 和 __import__() )</h2>
<p>😏 必用import_mosule。   __import__()这个有BUG， 多路径不能导入</p>
<h3 id="import_module">import_module</h3>
<pre><code>from importlib import import_module
parse = import_module('urllib.parse')   
parse.urlencode({'a':1})
# 正常运行
# 如果换成 __import__() 就会找不到模块，所以必用 import_module😏
</code></pre>
<h2 id="变量反射">变量反射</h2>
<p>hasattr+getattr</p>
<pre><code>hasattr(random,'randint')
randint = getattr(random,'randint')
print(randint(0,1))
</code></pre>
<p>delattr:</p>
<pre><code>delattr(random, 'randint')
</code></pre>
<h1 id="文件复制假移动真剪切">文件复制/假移动/真剪切</h1>
<p>shutil模块很好用。<br>
但是他的移动有说法：</p>
<pre><code>shutil.move() : 先复制后删除 （但稳定）
os.rename(): 剪切（神速）也可改名（）
</code></pre>
<p>复制正常用即可：</p>
<pre><code>shutil.copy(源路径，目标路径)    # 复制
</code></pre>
<h1 id="目录遍历-oswalk">目录遍历 os.walk</h1>
<pre><code>&quot;&quot;&quot;
    os.walk() 是一个深度遍历模式的文件遍历函数
    返回值是一个迭代器，遍历这个迭代器后，每一次的返回值都是如下顺序三种构成
        1. current_path: 当前路径 
        2. dir_list:     其下目录列表
        3. file_list:    其下文件列表
    
&quot;&quot;&quot;
import os
file_generator = os.walk('D:/虚拟E盘-代码空间/TF2')
for current_dir, dir_list, file_list in file_generator:
    print(current_dir, dir_list, file_list)
</code></pre>
<h1 id="非阻塞执行命令">非阻塞执行命令</h1>
<p>主要代替os.system</p>
<pre><code>import subprocess
res = subprocess.run('dir', shell=True, stdout=subprocess.PIPE) # 结果输入到res管道中去
print(res.stdout.decode('gbk'))    # res管道中有输出日志，如果在win下，需要 decode
</code></pre>
<h1 id="global-nonlocal">global &amp; nonlocal</h1>
<p>global 作用于普通函数与类中<br>
nonlocal  作用于闭包中</p>
<h1 id="np">np</h1>
<h2 id="求模">求模</h2>
<p>numpy:</p>
<pre><code>import numpy as np
a1 = np.ones([2,2])
result1 = np.linalg.norm(a1)
print(result1) # 2.0
</code></pre>
<p>tensorflow:</p>
<pre><code>import tensorflow as tf
a2 = tf.ones([2,2])
result2 = tf.norm(a2)
print(result2.numpy()) # 2.0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RS => NLP Model + TF20大纲]]></title>
        <id>https://cythonlin.github.io/post/rs-greater/</id>
        <link href="https://cythonlin.github.io/post/rs-greater/">
        </link>
        <updated>2021-03-03T07:10:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="贝叶斯学派-vs-频率派估计">贝叶斯学派 vs 频率派估计</h1>
<ol>
<li>贝叶斯分引入先验， 频率派(极大似然)则无</li>
<li>贝叶斯分布估计。 频率派是点估计（将参数当成随机变量求解）</li>
</ol>
<h1 id="伯努利分布">伯努利分布</h1>
<p>θ^y * （1-θ）^ (1-y)         [期望θ]</p>
<h1 id="对数线性模型">对数线性模型</h1>
<p>几率比：  p/(1-p)<br>
对数线性模型（就是在几率比的基础上加个log）： log( p/(1-p) ) = Θ^t * X<br>
将 上述 对数线性模型，两边同时取 e^， 则能推导出 sigmoid</p>
<h1 id="word-embedding之-word2vec">Word-Embedding之 Word2Vec</h1>
<h2 id="cbow-n预测1">CBOW （n预测1）</h2>
<p>核心原理：最小化(负样本词的概率) * 最大化(中心+上下文的词)<br>
只对中间词做负采样：</p>
<ul>
<li>选取中心词+上下文的词构成正样本</li>
<li>负采样其他词为负样本</li>
<li>计算loss对（所有上下文词+中心词向量的和 记作w） 和 （正负样本每个词的theta）的梯度</li>
<li>先更新 w，再更新theta。</li>
</ul>
<h2 id="skip-gram-1预测n">skip-gram （1预测n）</h2>
<p>核心原理：同样（所有上下文词+中心词向量的和 记作w）</p>
<ul>
<li>w中 （每个词 w'）都选出正负样本</li>
<li>计算loss对theta 和 w' 的偏导</li>
<li>更新w'的词向量（费劲，每次只能更新一个词 w'）需要更新n(个词)次</li>
</ul>
<h2 id="负采样类似-softmax">负采样（类似 softmax）</h2>
<ul>
<li>词 i 的长度(在0-1之间) = (词i出现的次数)^(3/4) /  (所有词出现次数)^(3/4) 的 和</li>
<li>每个词看作一个子线段的范围。  总线段为1。</li>
<li>然后另新建一个10^8长度的线段，按照不同比例尺和 上述长度1线段保持对齐（也划分出一样的刻度）。</li>
<li>然后生成随机数，随机数所在10^8线段对应的，0-1线段的刻度（也就是某个词i）, 此词即为负样本。</li>
</ul>
<h2 id="word-embeddingword2vec作用">Word Embedding（Word2Vec）作用</h2>
<p>作为预训练模型，呗当作上游任务， 目的是拿到下游任务中使用。<br>
下游任务老式结构：</p>
<pre><code>N个单词 =&gt; one-hot =&gt; 
    将这些单词都乘训练好的Word Embedding矩阵(查表，取出每个单词对应的Embedding)
         =&gt; DNN....
</code></pre>
<p>在 Word Embedding这里：</p>
<ul>
<li>可以选择固定word embedding层级参数模式（frozen）</li>
<li>也可以训练后面DNN架构时，连同训练 word embedding 参数模式（fine-tune）</li>
</ul>
<p>Word Embedding （Word2Vec）效果：</p>
<pre><code>效果不明显
</code></pre>
<p>阻碍原因 =&gt; 同义词</p>
<pre><code>有些词是一词多义， 但是却都i体现在了一个词上， 自然只占用了一个词的空间。
导致 两种上下文信息 都会编码到同一个 Word Embedding空间里去。
</code></pre>
<p>下面的 ELMO可以解决多义词问题👇</p>
<h2 id="elmoembedding-from-language-models">ELMO(Embedding from language Models)</h2>
<p>👉属于特征融合预训练类。<br>
结构：</p>
<pre><code>一层Word Embedding + 双层双向LSTM  （总共可以看作三层）（当然最后有个输出层）
</code></pre>
<p>所以每个词，经过后，都能得到 3个 embedding （就是下面的三层👇）<br>
每层的作用：</p>
<ul>
<li>1层：单词的 Word Embedding</li>
<li>2层：单词的 句法信息   （词性、短语类型、句子成分。）</li>
<li>3层：单词的 语义信息   （理解单词的表达的意思）</li>
</ul>
<p>ELMO的下游使用：</p>
<ol>
<li>上面3个 Embedding 加一个权重w (这个w可以通过学习学到)。并加权求和。</li>
<li>上面的加权求和结果就可以被看作 一个特征， 这个特征供给下游任务，(QA答句)的embedding使用（这也是特征融合）</li>
<li>由于ELMO是动态根据上下文去调整 embedding，并且还有语义+语句的共同约束，所以同义词冲突由此解决， 也就不会出现 play这个多义词 由于之前所在环境都是体育类，而导致get不到  &quot;演出&quot;的语义</li>
</ol>
<p>缺点：</p>
<pre><code>使用的是 lstm 而不是 Transformer 作为 特征提取器
</code></pre>
<h2 id="gptgenerative-pre-training">GPT（Generative Pre-Training）</h2>
<p>优点：</p>
<pre><code>特征抽取用的： Transformer， 而非 LSTM等RNN系 (RNN并行计算弱)
Transformer (用了叠加的 self attention)
</code></pre>
<p>缺点：</p>
<pre><code> GPT只用了上文 （白白浪费了 下文信息 （就是只看句子中这个单词之前的信息。之后的不看））
 ELMO用的 上下文（上下文都有）
</code></pre>
<p>特点：  tine-tune</p>
<pre><code>上游任务：Transfomer
👉主要是下下游任务的使用：
    1. 下游任务需要还原 和 上游的GPT模型一样的结构。 
    2. 具体只需拿到GPT上游结构， 然后在输出层 修改成自己 需要的 场景即可
</code></pre>
<h2 id="bert">Bert</h2>
<p>第一阶段（上游）：Bert预训练模型阶段 和 GPT 一样， Bert的改进：</p>
<pre><code>1. 双向语言模型（上下文都照顾到）
2. 模型数据规模比 GPT大
</code></pre>
<p>第二阶段（下游任务）：</p>
<pre><code>1. 序列标注（词性标注，NER，语义角色标注）
2. 分类任务（文本分类，情感分类）
3. 句子关系判断（给2个句子，推断这2个句子的语义关系）
    1. 文本蕴含（Textual Entailment）给定一个前提文本（premise），根据这个前提去推断假说文本（hypothesis）与premise的关系
    2. QA
    3. 语义改写
    4. 自然语言推理
4. 生成式：（输入文本后，生成一段语句）
    1. 机器翻译
    2. 写诗
    3. 文本摘要
    4. 看图说话
</code></pre>
<p>Masked双向语言模型的具体实现：</p>
<pre><code>随机选择语料中15%的单词，把它抠掉，或者说用[Mask]掩码代替原始单词
然后要求模型去正确预测被抠掉的单词。

因为[mask] 填补过多，会被模型认为[mask]标记才是主要的。
所以，BERT对此做了改进：
    1.  这15%中的  80% 做 [mask]标记
    2.  10%被替换为另外一个词
    3.  剩下的10%原地不动
</code></pre>
<p>除了 masked，bert还做了 Next Sentence Prediction，具体实现：</p>
<pre><code>语言模型预训练的时候，分两种情况选择两个句子：
1. 一种是选择语料中真正顺序相连的两个句子
2. 另外一种是第二个句子从语料库中随机选择一个拼到第一个句子后面
</code></pre>
<p>根据上述来判断第二个句子是不是紧贴着第一个句子。</p>
<p>Bert输入结构：</p>
<pre><code>它的输入部分是个线性序列，两个句子通过分隔符分割，最前面和最后增加两个标识符号。

每个单词有三个embedding:
    1. embedding1: 位置信息embedding
    2. embedding2: 单词embedding
    3. embedding3: 句子embedding

将上述3个embedding叠加，即作为 Bert的输入。
</code></pre>
<h1 id="-">---------------------------------------------</h1>
<h1 id="下面内容总结摘自">下面内容总结摘自</h1>
<p><a href="https://blog.csdn.net/ibelieve8013">Jamie_Wu 's Blog</a>  ，Copy一份，在此谢过！</p>
<h1 id="tf10-总览">TF10 总览</h1>
<figure data-type="image" tabindex="1"><img src="https://cythonlin.github.io/post-images/1615788904931.png" alt="" loading="lazy"></figure>
<h1 id="tf20api-总览">TF20API 总览</h1>
<figure data-type="image" tabindex="2"><img src="https://cythonlin.github.io/post-images/1615788968398.png" alt="" loading="lazy"></figure>
<h1 id="keras-总览">Keras 总览</h1>
<figure data-type="image" tabindex="3"><img src="https://cythonlin.github.io/post-images/1615788997656.png" alt="" loading="lazy"></figure>
<h1 id="data-总览">data 总览</h1>
<figure data-type="image" tabindex="4"><img src="https://cythonlin.github.io/post-images/1615789035599.png" alt="" loading="lazy"></figure>
<h1 id="estimator-总览">estimator 总览</h1>
<figure data-type="image" tabindex="5"><img src="https://cythonlin.github.io/post-images/1615789117772.png" alt="" loading="lazy"></figure>
<h1 id="cnn-总览">cnn 总览</h1>
<figure data-type="image" tabindex="6"><img src="https://cythonlin.github.io/post-images/1615789161158.png" alt="" loading="lazy"></figure>
<h1 id="rnn-总览">rnn 总览</h1>
<figure data-type="image" tabindex="7"><img src="https://cythonlin.github.io/post-images/1615789172168.png" alt="" loading="lazy"></figure>
<h1 id="分布式-总览">分布式 总览</h1>
<figure data-type="image" tabindex="8"><img src="https://cythonlin.github.io/post-images/1615789188015.png" alt="" loading="lazy"></figure>
<h1 id="保存部署-总览">保存部署 总览</h1>
<figure data-type="image" tabindex="9"><img src="https://cythonlin.github.io/post-images/1615789205396.png" alt="" loading="lazy"></figure>
<h1 id="seq2seq-总览">seq2seq 总览</h1>
<figure data-type="image" tabindex="10"><img src="https://cythonlin.github.io/post-images/1615789344979.png" alt="" loading="lazy"></figure>
<h1 id="transformer-总览">transformer 总览</h1>
<figure data-type="image" tabindex="11"><img src="https://cythonlin.github.io/post-images/1615789348852.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>