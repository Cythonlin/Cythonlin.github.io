<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>PY =&gt; Spark mapPartition | Cython_lin</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cythonlin.github.io/favicon.ico?v=1601387068833">
<link rel="stylesheet" href="https://cythonlin.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="正解
map()：每次处理一条数据
mapPartition()：每次处理一个分区的数据，这个分区的数据处理完后，原RDD中分区的数据才能释放，可能导致OOM
当内存空间较大的时候建议使用mapPartition()，以提高处理效率
分隔
..." />
    <meta name="keywords" content="RS" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cythonlin.github.io">
        <img src="https://cythonlin.github.io/images/avatar.png?v=1601387068833" class="site-logo">
        <h1 class="site-title">Cython_lin</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cythonlin.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">PY =&gt; Spark mapPartition</h2>
            <div class="post-date">2020-09-29</div>
            
            <div class="post-content" v-pre>
              <h1 id="正解">正解</h1>
<p>map()：每次处理一条数据</p>
<p>mapPartition()：每次处理一个分区的数据，这个分区的数据处理完后，原RDD中分区的数据才能释放，可能导致OOM</p>
<p>当内存空间较大的时候建议使用mapPartition()，以提高处理效率</p>
<h1 id="分隔">分隔</h1>
<p>下面所有是自己的思路，推到最后给自己推蒙了，可以掠过</p>
<h1 id="正文实验可忽略直奔结果">正文实验（可忽略，直奔结果）</h1>
<p>为了方便，用把组装的数据类型灌入 map 来模拟 mapPartitions<br>
功能是模拟计算 tf-idf</p>
<pre><code>class Article:
    '''文章类'''
    def __init__(self,id, indexex, tfidfs):
        self.id = id
        self.indexex = indexex   # 文章分词后的所有词索引列表
        self.tfidfs = tfidfs     # 每个词对应的TF-IDF值 列表

def f(partition):
    for row in partition:   # row 代表每个文章
        # row.indexex 代表 文章分词后的所有词索引列表
        # row.tfidfs  代表 每个词对应的TF-IDF值 列表
        word_list = list(zip(row.indexex, row.tfidfs))  
        
        for index, tfidf in word_list:    # 遍历 &quot;每个&quot;词语 的 index与tfidf
            ########### 这里 yield 是重点 ###########
            yield f'文章{row.id}', index, tfidf
            

c = map(f, 
    [   #  &lt;-为了模拟分区，这一层的列表代表partition
        [   # &lt;- 这一层模拟的是每个分区里面的文章列表
            Article(0, [1,2],[0.1,0.4] ),   # &lt;-文章0
            Article(1, [3,4],[3.4,3.7] )    # &lt;-文章1
        ] 
    ] 
)
######################## 执行 ########################
for x in c:              # 解zip
    print(list(x))       # 解yield
</code></pre>
<h1 id="结果">结果：</h1>
<p>如果使用 return 关键词，得出的最终打印结果: （不满足）</p>
<pre><code>['文章0', 1, 0.1]          
</code></pre>
<p>如果使用 yield 关键词，得出的最终打印结果:  （满足）</p>
<pre><code>[('文章0', 1, 0.1), ('文章0', 2, 0.4), ('文章1', 3, 3.4), ('文章1', 4, 3.7)]
</code></pre>
<h1 id="这里就出现了一个问题">这里就出现了一个问题：</h1>
<p>正常用法都是用 return，时常用 lambda（lambda默认也是隐式 return。）<br>
是何原因让我们不得不用 yield?<br>
一点一点往下推：</p>
<pre><code>map: 核心是 &quot;按单个数据映射&quot;
mapPartition： 核心是&quot;把数据分组，按组映射&quot;
    按组映射是没错，但我们的目的是想操作组内的每条数据。
    所以我们必须需要每次对组内数据 for循环遍历出来单独处理。         然后 返回回去。
</code></pre>
<p>那我们先用正常的 return 返回试试：</p>
<pre><code>def(partation):
    for x in partition:
        return x.name, x.age
</code></pre>
<p>也许看到这里你觉得没什么问题。。。<br>
但是不要忘了最基础的内容， return 是直接跳出 for 循环和函数的。<br>
再次强调，mapPartition是按组映射，所以仔细看上面代码:<br>
最终的mapPartition是按组映射结果就是：<br>
每组的第一个元素的集合 （因为for被return了，每组的函数也被return了）<br>
解决这种问题，有两种方式：</p>
<ol>
<li>
<p>最简单将源代码for循环内部的 return 改为 yield</p>
</li>
<li>
<p>新建临时列表过渡，return放在for外面，如下案例：</p>
<p>def f(partition):<br>
_ = []<br>
for x in partition:<br>
_.append(x)<br>
return _<br>
b = [[1,2,3], [4,5,6]]<br>
c = map(f,b)<br>
print(list(c))</p>
</li>
</ol>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://cythonlin.github.io/tag/EjFvvnhFs/" class="tag">
                    RS
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://cythonlin.github.io/post/rs-greater-tui-jian-xi-tong-yi-huan-jing-pei-zhi-shu-ju-shou-ji/">
                  <h3 class="post-title">
                    RS =&gt; 推荐系统（一）环境配置+数据收集
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
